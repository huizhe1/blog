{"meta":{"title":"Huizhe","subtitle":"记录一些学习心得","description":"命运常以痛为吻，我们仍要报之以歌，情深义重","author":"灰者","url":"https://www.huizhe.zxy"},"pages":[{"title":"","date":"2018-07-27T08:55:31.363Z","updated":"2017-10-12T09:42:54.000Z","comments":true,"path":"404.html","permalink":"https://www.huizhe.zxy/404.html","excerpt":"","text":"404页面 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num 暂时未能找到您查找的页面 可能输入的网址错误或此页面不存在 秒后自动跳转到主页"},{"title":"about","date":"2017-10-09T13:12:02.000Z","updated":"2018-07-27T09:29:10.723Z","comments":true,"path":"about/index.html","permalink":"https://www.huizhe.zxy/about/index.html","excerpt":"","text":"关于我—huizhe2015 - 2019就读于广东韶关学院，专业是软件工程在校期间，加入网园资讯工作室 编程部，主要职责是利用ASP.NET完成学校官网的制作及修改课余时间，学习利用PHP，完成一些项目的开发，主要有大创项目，成绩查询和课程系统。目前，在学习JAVA开发，主要学习三大框架以及Redis集群。 联系方式email: a22783276@163.com"},{"title":"categories","date":"2017-10-09T14:46:33.000Z","updated":"2017-10-09T14:47:10.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.huizhe.zxy/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-09T14:47:48.000Z","updated":"2017-10-09T14:48:02.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.huizhe.zxy/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"聊聊 JAVA 异常","slug":"Throwable","date":"2018-07-29T10:35:21.000Z","updated":"2018-07-29T10:47:46.587Z","comments":true,"path":"Throwable/","link":"","permalink":"https://www.huizhe.zxy/Throwable/","excerpt":"","text":"异常对象都是派生于Throwable 类的一个实例。 异常层次结构简化示意图: 所有的异常都是由Throwable 继承而来，但在下一层立即分解为两个分支：Error 和 Exception Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误 Exception 层次Exception 层次分解为两个分支： RuntimeException 和 其他异常 RuntimeException 异常： 错误的类型转换 ClassCastException 数组访问越界 ArrayIndexOutOfBoundsException 访问null指针 NullPointerException 不是派生于 RuntimeException 异常包括： 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在 Java语言规范将派生于 Error 异常或 RuntimeException 类的所有异常称为非受查(unchecked) 异常。 所有其他的异常称为受查(checked)异常。 什么时候该抛出异常 throws ： 调用一个抛出受查异常的方法 运行时发现错误，利用 throw 语句抛出一个受查异常 程序出现错误，如 ArrayIndexOutOfBoundsException 这样的非受查异常 Java 虚拟机和运行时库出现的内部错误 子类方法中声明的受查异常并不能比超类方法中声明的异常更通用，即子类方法中可抛出更特定的异常，或者根本不抛出任何异常。特别声明：如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。 自定义异常： 定义一个派生于Exception的类，或者派生于Exception子类的类。 习惯上，定义的类应该包含两个构造器。一个默认的构造器，另一个是带有详细描述信息构造器。 12345678class FileFormatException extends IOException&#123; public FileFormatException()&#123;&#125; public FileFormatException(String message) &#123; super(message); &#125;&#125; API java.lang.Throwable Throwable() 构造一个新的Throwable 对象，这个对象没有详细的描述信息 Throwable(String message) 构造一个新的Throwable，这个对象带有特定的详细描述信息。习惯上，所有的派生的异常类都支持一个默认的构造器和一个带有详细信息的构造器。 String getMessage() 获得Throwable 对象的详细描述信息 异常处理小技巧一般异常处理最好的选择，就是将异常传递给调用者，让调用者自己去操心。 在catch 字句中可以抛出一个异常，这样做的目的是改变异常的类型。我们可以采用一种比较推荐的处理异常的方法，并且将原始异常设置为新异常的”原因”: 12345678910try&#123; access the database&#125;catch(SQLException e)&#123; Throwable se = new ServletException(\"database error\"); se.initCause(e); throw se;&#125; 当捕获到异常时，就可以使用下面这条语句重新得到原始异常：1Throwable e = se.getCause(); 使用这种包装技术，可让用户抛出子系统中的高级异常，而不会丢失原始异常的细节 如果在一个方法中发生了一个受查异常，而不允许抛出它，那包装技术就十分有用。我们可捕获这个受查异常，并将它包装成一个运行时异常。 finally 语句 不管是否有异常被捕获，finally 字句中的代码都被执行。 当finally字句包含return 语句时，将会出现一种意想不到的结果。 假设利用return 语句从try语句块中退出。在方法返回前，finally字句的内容将被执行。如果finally字句中也有一个return语句，这个返回值将会覆盖原始的返回值。例： 123456789 public static int f(int n)&#123; try&#123; return n*n; &#125;finally &#123; if (2 == n) return 0; &#125;&#125; 如果调用f(2) ，try语句返回结果为4，然而在方法返回前，要执行finally字句。finally字句使得方法返回0。这个返回值覆盖了原先的返回值4。所以调用 f(2) 返回的值为 0。 JAVA SE7 关闭资源的处理待资源的try 语句(try-with-resources) 的最简形式1234try(Resource res = ...)&#123; work with res&#125; try 块退出时，会自动调用res.close() 指定多个资源：12345try(Scanner in = new Scanner(new FileInputStream(\"/usr/shar/dict/words\"),\"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\"))&#123; while (in.hasNext()) out.println(in.next().toUpperCase());&#125; 不管这个块如何退出，in 和 out 都会关闭。 常规方式手动编程，就需要两个嵌套的try/finally 语句。 堆栈轨迹(stack trace)堆栈轨迹是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。 访问堆栈轨迹的文本描述信息12345Throwable t = new Throwable();StackTraceElement[] frames = t.getStackTrace();for (StackTraceElement frame : frames)&#123; analyze frame&#125; StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法。同时，还含有能够获得类名和方法名的方法。 静态的 Thread.getAllStackTrace 方法，它可以产生所有线程的堆栈轨迹。例12345Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();for (Thread t : map.keySet())&#123; StackTraceElement[] frames = map.get(t); analyze frames&#125; 打印一个递归阶乘的函数的堆栈情况123456789101112131415161718192021222324252627282930public class StackTraceTest &#123; /** * 计算n的阶乘 * @param n * @return */ public static int factorial(int n) &#123; System.out.println(\"factorial(\" + n + \"):\"); Throwable t = new Throwable(); StackTraceElement[] frames = t.getStackTrace(); for (StackTraceElement f: frames) System.out.println(f); int r; if (n&lt;=1) r =1; else r = n * factorial(n-1); System.out.println(\"return \" + r); return r; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.print(\"Enter n : \"); int n = in.nextInt(); factorial(n); &#125;&#125; 计算factorial(3),打印一下内容123456789101112131415factorial(3):javabook.StackTraceTest.factorial(StackTraceTest.java:15)javabook.StackTraceTest.main(StackTraceTest.java:32)factorial(2):javabook.StackTraceTest.factorial(StackTraceTest.java:15)javabook.StackTraceTest.factorial(StackTraceTest.java:23)javabook.StackTraceTest.main(StackTraceTest.java:32)factorial(1):javabook.StackTraceTest.factorial(StackTraceTest.java:15)javabook.StackTraceTest.factorial(StackTraceTest.java:23)javabook.StackTraceTest.factorial(StackTraceTest.java:23)javabook.StackTraceTest.main(StackTraceTest.java:32)return 1return 2return 6 使用异常小技巧异常处理不能代替简单的测试与执行简单的测试相比，捕获异常所花费的时间大大超过前者。因此使用异常的基本规则是，旨在异常情况下使用异常机制。 不要过分地细化异常将整个任务包装在一个try块中，这样，当任何一个操作出现问题时，整个任务都可以取消。 利用异常层次结构 不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。 不要只捕获Throwable 异常，否则，会使程序代码更难读、更难维护 考虑受查异常和非受查异常的区别。 将一种异常转换成另一种更加适合的异常时不要犹豫。 不要压制异常在java中，往往强化地倾向关闭异常。 在检测错误时，“苛刻”要比放任更好例如，当栈空时，Stack.pop 是要返回一个null，还是抛出一个异常？我们认为：在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。 不要羞于传递异常让高层次的方法通知用户发生了错误，或者放弃不成功的命令更加适宜。 5 和 6 可以归纳为“早抛出，晚捕获”。参考JAVA核心技术（卷1）原书第10版","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.zxy/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.zxy/tags/JAVA/"}]},{"title":"浅谈反射","slug":"reflection","date":"2018-07-27T08:29:41.000Z","updated":"2018-07-27T09:12:23.970Z","comments":true,"path":"reflection/","link":"","permalink":"https://www.huizhe.zxy/reflection/","excerpt":"反射：能够分析类能力的程序称为反射。反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。 反射机制：当程序无法获知对象类型时，在运行期间动态获取类的所有属性和方法。","text":"反射：能够分析类能力的程序称为反射。反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。 反射机制：当程序无法获知对象类型时，在运行期间动态获取类的所有属性和方法。 反射机制作用 在运行时分析类的能力 在运行时查看对象 实现通用的数组操作代码 反射机制的实现采用Class类和java.lang.reflect 类库一起实现 &lt;反射&gt;机制 Class 类： 代表一个目标类。 Field 类： 代表目标类的成员变量。 Method 类： 代表目标类的方法。 Constructor 类： 代表目标类的构造方法。 Array 类： 提供了动态创建数组，以及访问数组的元素的静态方法。 Class 类​ 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型表示。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 ​ 然而，可以通过专门的Java类访问这些信息。保存这些信息的类被成为Class，这个名字很容易让人混淆。Object 类中的getClass() 方法将返回一个Class类型的实例。 获取Class对象的三种方法 如果类在一个包里，包的名字也作为做类名的一部分。 123Random generator = new Random();Class cl = generator.getClass();System.out.println(cl.getName());//java.util.Random 如果类名保存字符串中，并可在运行时该变，即可使用这种方法。forName() 方法会爆ClassNotFoundException 异常，所以需要进行异常处理。 Class.forName() 内部通过反射API根据目标类名将类手动加载到内存中，称为类加载器加载方法。加载过程中会把目标类的static方法，变量，代码块加载到JVM，注意此时尚未创建对象实例 12String className = \"java.util.Random\";Class cl = class.forName(className); 如果T是任意的Java类型（或void 关键字），T.class 将代表匹配的类对象 1Class cl = Random.class; 获取构造器–Constructor 类 Constructor[] getConstructors()：获得所有public构造器； Constructor[] getDeclaredConstructors()：获得所有访问权限的构造器 Constructor getConstructor(Class[] params)：根据指定参数获得对应构造器； Constructor getDeclaredConstructor(Class[] params)：根据指定参数获得对应构造器； 获得方法–Method 类 Method[] getMethods()：获得所有public方法； Method[] getDeclaredMethods()：获得所有访问权限的方法； Method getMethod(String name, Class[] params)：根据方法签名获取类自身对应public方法，或者从基类继承和接口实现的对应public方法； Method getDeclaredMethod(String name, Class[] params)：根据方法签名获得对应的类自身声明方法，访问权限不限； 获得变量–Field 类 Field[] getFields()：获得类中所有public变量 Field[] getDeclaredFields()：获得类中所有访问权限变量 Field getField(String name)：根据变量名得到对应的public变量 Field getDeclaredField(String name)：根据变量名获得对应的变量，访问权限不限； 实战我们来个例子加深一下印象。 打印一个类的所有构造函数1234567891011121314151617181920public static void printConstructors(Class cl) &#123; //返回包含Constructor 对象的数组，其中包含了Class对象的所有构造器 Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c: constructors) &#123; //String getName() //返回一个用于描述构造器、方法或域名的字符串 String name = c.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+ \" \"); System.out.print(name+\"(\"); //Class[] getParameterTypes() (在Constructor 和 Method 类中) //返回一个用于描述参数类型的Class对象数组 printParameterType(c.getParameterTypes()); System.out.println(\");\"); &#125; &#125; 打印一个类的所有方法123456789101112131415161718192021public static void printMethods(Class cl) &#123; //返回包含Method 对象的数组，返回这个类或接口的全部方法，但不包括由超类继承了的方法 Method[] methods = cl.getDeclaredMethods(); for (Method m:methods) &#123; //Class getReturnType() (在 Method 类中) //返回一个用于描述返回类型的Class对象 Class retType = m.getReturnType(); String name = m.getName(); System.out.print(\" \"); //打印修饰符、返回类型和方法名称 String modifiers =Modifier.toString(m.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+\" \"); System.out.print(retType.getName()+\" \"+ name + \"(\"); printParameterType(m.getParameterTypes()); System.out.println(\");\"); &#125; &#125; 打印一个类的所有字段12345678910111213141516public static void printFields(Class cl) &#123; //Field[] getDeclaredFields() //返回包含Field 对象的数组，这些对象记录了这个类的全部域 Field[] fields = cl.getDeclaredFields(); for (Field f : fields)&#123; Class type = f.getType(); String name = f.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+\" \"); System.out.println(type.getName()+\" \"+ name+ \";\"); &#125; &#125; 打印方法的参数类型12345678public static void printParameterType(Class[] paramTypes) &#123; for (int j = 0;j&lt;paramTypes.length;j++) &#123; if (j&gt;0) System.out.print(\", \"); System.out.print(paramTypes[j].getName()); &#125; &#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; String name; if (args.length&gt;0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println(\"Enter class name(e.g java.util.Date): \"); name = in.next(); &#125; try &#123; //print class name and superclass name (if != object) //调用Class 的静态方法 forName 获得类名对应的Class 对象 Class cl = Class.forName(name); //获取父类所对应的Class 对象 Class supercl = cl.getSuperclass(); //返回对应modifiers 中位设置的修饰符的字符串表示 String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+\" \"); System.out.print(\"class \"+ name); //判断是否有继承父类 if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(\" extends \"+ supercl.getName()); System.out.print(\"\\n&#123;\\n\"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(\"&#125;\"); &#125;catch (ClassNotFoundException ex) &#123; ex.printStackTrace(); &#125; System.exit(0); &#125; 参考 JAVA核心技术（卷1）原书第10版 反射笔记","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.zxy/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.zxy/tags/JAVA/"}]},{"title":"机器学习之识别验证码","slug":"Tesseract","date":"2018-03-19T14:55:57.000Z","updated":"2018-08-03T03:30:24.905Z","comments":true,"path":"Tesseract/","link":"","permalink":"https://www.huizhe.zxy/Tesseract/","excerpt":"","text":"下载 tesseract_ocr使用composer下载，tesseract_ocr1$ composer require thiagoalessio/tesseract_ocr ocr 测试123456require_once './vendor/autoload.php';use thiagoalessio\\TesseractOCR\\TesseractOCR;echo (new TesseractOCR('./1.jpg')) -&gt;lang('eng') -&gt;run(); 训练样本数据安装 Tesseract笔者这里是直接自动安装，没选择编译安装 1$ sudo apt install tesseract-ocr 下载图片12345678function getPicture($uri)&#123; for($i=0;$i&lt;100;$i++) &#123; $img = file_get_contents($uri); $filename = './test/'.$i.'.gif'; file_put_contents($filename,$img); &#125;&#125; 下载之后有点小问题，因为笔者电脑少了一个gif库，后面处理的时候总是有点问题。所以我用软件将 gif 转成了 png 格式. 安装 jTessBoxEditor 下载地址 笔者下载的是 jTessBoxEditor-2.0-Beta.zip 解压 1$ unzip jTessBoxEditor-2.0-Beta.zip 运行 1$ java -Xms128m -Xmx1024m -jar jTessBoxEditor.jar 图片转换成 tiff 格式因为jTessBoxEditor只能处理.tiff后缀的文件，因此我们需要将验证码图片转化为.tiff后缀，这里我们使用ImageMagick的convert工具进行转化，首先安装ImageMagick： 1$ sudo apt-get install imagemagick shell 脚本批量转换当前目录下的图片 创建 tran.sh 文件 1$ vim tran.sh tran.sh 文件内容 123456#~/bin/shfor file in `ls *.jpg` do name=$&#123;file%.*&#125; convert $file \"../tiff/\"$name\".tiff\" done 图片转换 1$ ./tran.sh 将 .tiff 文件合并成 .tif 文件打开 jTessBoxEditor ，点击界面上的Tools/Merge TIFF，将之前生成的 .tiff 文件合并成一个 .tif文件 官方定义 tif 文件的命名格式为：[lang].[fontname].exp[num].tif 生成 .box 文件1$ tesseract eng.test.exp0.tif eng.test.exp0 -l eng -psm 7 batch.nochop makebox 使用jTessBoxEditor校正字符打开刚才生成的eng.test.exp0.tif 文件，在左侧的Char列输入正确的值，调整x，y，w，h的值。可选择工具栏上的merge 和 split 对结果进行合并和拆分。点击下方中间的翻页查看下一张验证码。 自制语言库定义字体特征文件1$ echo test 0 0 0 0 0 &gt; font_properties 语法： fontname italic bold fixed serif fraktur fontname为字体名称，italic为斜体，bold为黑体字，fixed为默认字体，serif为衬线字体，fraktur德文黑字体，1和0代表有和无，精细区分时可使用。 生成字符特征文件1$ tesseract eng.test.exp0.tif eng.test.exp0 -l eng -psm 7 nobatch box.train 产生字符集1unicharset_extractor eng.test.exp0.box 生成shapetable1$ shapeclustering -F font_properties -U unicharset -O eng.test.exp0 eng.test.exp0.tr 生成聚集字符特征文件1$ mftraining -F font_properties -U unicharset -O eng.test.exp0 eng.test.exp0.tr 生成字符形状正常变化特征文件normproto12 cntraining eng.test.exp0.tr$ combine_tessdata test. 给inttemp,normproto,pffmtable,shapetable,unicharset 添加前缀 “test.”。生成语言库123456789101112131415161718192021$ combine_tessdata test.Combining tessdata filesTessdataManager combined tesseract data files.Offset for type 0 (test.config ) is -1Offset for type 1 (test.unicharset ) is 140Offset for type 2 (test.unicharambigs ) is -1Offset for type 3 (test.inttemp ) is 891Offset for type 4 (test.pffmtable ) is 137813Offset for type 5 (test.normproto ) is 137935Offset for type 6 (test.punc-dawg ) is -1Offset for type 7 (test.word-dawg ) is -1Offset for type 8 (test.number-dawg ) is -1Offset for type 9 (test.freq-dawg ) is -1Offset for type 10 (test.fixed-length-dawgs ) is -1Offset for type 11 (test.cube-unicharset ) is -1Offset for type 12 (test.cube-word-dawg ) is -1Offset for type 13 (test.shapetable ) is 139557Offset for type 14 (test.bigram-dawg ) is -1Offset for type 15 (test.unambig-dawg ) is -1Offset for type 16 (test.params-model ) is -1Output test.traineddata created successfully. 语言库存到tesseract中1$ sudo cp test.traineddata /usr/share/tesseract-ocr/tessdata/ 对比12345678910111213for ($i=0; $i &lt; 100; $i++) &#123; echo $i.\":\".(new TesseractOCR('./test/'.$i.'.jpg')) -&gt;lang('test') -&gt;run(); echo '\\r';&#125;for ($i=0; $i &lt; 100; $i++) &#123; echo $i.\":\".(new TesseractOCR('./test/'.$i.'.jpg')) -&gt;lang('eng') -&gt;run(); echo '\\r';&#125; 笔者用100张照片去对比，结果如下 因为eng是还有匹配字母，所有速度和正确率方面有所影响。test我主要是校正数字，所以速度上相对有优势，加上训练数据不大，正确率不是很高。 语言库 eng test 识别率 52% 69% Tesseract 识别的图片如果太脏，需要清洗一下，否则极影响识别率。","categories":[{"name":"php","slug":"php","permalink":"https://www.huizhe.zxy/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.huizhe.zxy/tags/php/"}]},{"title":"软考爬虫","slug":"Software","date":"2018-03-12T10:12:58.000Z","updated":"2018-08-03T03:30:43.260Z","comments":true,"path":"Software/","link":"","permalink":"https://www.huizhe.zxy/Software/","excerpt":"最近和同学在一起准备报考 计算机技术与软件专业技术资格（水平）考试，不过因为报名时间还没出，所以一直得关注网站是否已经可以报考。 刚好又在弄php的爬虫，所以就顺手做一个爬虫，再搭配一下Twilio做一个预警通知，就不用关注网站了，这样就轻松了很多。","text":"最近和同学在一起准备报考 计算机技术与软件专业技术资格（水平）考试，不过因为报名时间还没出，所以一直得关注网站是否已经可以报考。 刚好又在弄php的爬虫，所以就顺手做一个爬虫，再搭配一下Twilio做一个预警通知，就不用关注网站了，这样就轻松了很多。 注意：这里爬虫访问的是 广东人事考试网 使用工具：QueryList Twilio 先放一张成品图. 这里还没出2018的，所以用2017的测试 TwilioTwilio是一个做成开放插件的电话跟踪服务（call-tracking service）。美国当地时间2016年6月23日，云通讯公司Twilio在纽约证券交易所上市（来自于百度百科）。Twilio官网从国内访问的时候，可能会因为一些你懂的原因而导致无法访问，这时你就得学习一下怎么科学上网了。 QueryListQueryList是一个基于phpQuery的PHP通用列表采集类,得益于phpQuery，让使用QueryList几乎没有任何学习成本，只要会CSS3选择器就可以轻松使用QueryList了，它让PHP做采集像jQuery选择元素一样简单。 Twilio注册注册方法请移步 崔庆才 大神的博客，这里就不重复了。 安装因为是PHP版本的，所以用composer进行安装 Twilio PHP &gt;= 5.3 1composer require twilio/sdk QueryList PHP &gt;= 7.0 1composer require jaeger/querylist Twilio 代码1234567891011121314151617require_once &apos;./vendor/autoload.php&apos;;use Twilio\\Rest\\Client;function SendSMS($body)&#123; $account_sid = &quot;your account sid&quot;; $auth_token = &quot;your token&quot;; $client = new Client($account_sid, $auth_token); $messages = $client-&gt;messages-&gt;create( &quot;+接收者的号码&quot;, array( &apos;from&apos; =&gt; &apos;+twilio给你的号码&apos;, &apos;body&apos; =&gt; $body ) );&#125; QueryList 代码12345678910111213141516171819202122232425262728293031323334353637383940require_once &apos;./vendor/autoload.php&apos;;use QL\\QueryList;function getHtmlData($uri, $rules, $range)&#123; $html = QueryList::get($uri)-&gt;getHtml(); $data = QueryList::html($html)-&gt;rules($rules)-&gt;range($range) -&gt;query()-&gt;getData(); return $data-&gt;all();&#125;function send($uri)&#123; $rules = array( &apos;content&apos; =&gt; array(&apos;p&apos;,&apos;text&apos;), &apos;link&apos; =&gt; array(&apos;a&apos;,&apos;href&apos;) ); $range = &apos;#fontzoom&apos;; $dataArray = getHtmlData($uri, $rules, $range); $time = explode(&apos;：&apos;,explode(&apos;。&apos;,$dataArray[0][&apos;content&apos;])[0])[2]; $body = $time.&apos;。报名入口：&apos;.$dataArray[0][&apos;link&apos;]; SendSMS($body);&#125;$uri = &quot;http://www.gdrsks.gov.cn/HREducation/ExamList.aspx?ecid=2&amp;nodeid=1&amp;ekid=19&quot;;$rules = array( &apos;date&apos; =&gt; array(&apos;.date&apos;,&apos;text&apos;), &apos;content&apos; =&gt; array(&apos;.tit&apos;,&apos;text&apos;), &apos;link&apos; =&gt; array(&apos;.tit&apos;,&apos;href&apos;));$range = &apos;#mainContent&gt;div.wBd&gt;ul&gt;li&apos;;$data = getHtmlData($uri, $rules, $range);foreach ($data as $value) &#123; $array = explode(&apos;-&apos;, $value[&apos;date&apos;]); if (count($array) == 1) continue; if ($array[0] == &apos;2018&apos;) &#123; $uri = &apos;http://www.gdrsks.gov.cn&apos;.$value[&apos;link&apos;]; $uri = explode(&apos;&amp;&apos;,$uri)[0]; send($uri); break; &#125;&#125; 定时任务123crontab -e30 7 * * * /usr/bin/php your_file_pathsystemctl restart cron","categories":[{"name":"php","slug":"php","permalink":"https://www.huizhe.zxy/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.huizhe.zxy/tags/php/"},{"name":"crawler","slug":"crawler","permalink":"https://www.huizhe.zxy/tags/crawler/"}]},{"title":"Mysql和MariaDB 笔记","slug":"Mysql","date":"2018-02-27T08:29:41.000Z","updated":"2018-07-27T08:24:19.788Z","comments":true,"path":"Mysql/","link":"","permalink":"https://www.huizhe.zxy/Mysql/","excerpt":"","text":"含有空用户名加上localhost的组合，即任何用户名都可从localhost登陆 设置初始密码 mysqladmin -u root -p flush-privileges password “new_pwd”; mysqladmin 必须软链接到PATH中 Linux中：/usr/local/mysql/bin/mysqladmin 查看用户 mysql -u root -p -e “SELECT User,Host FROM mysql.user;”; 删除组合 mysql -u root -p -e “drop USER ‘root’@’%’;” 设置密码 mysql -u root -p -e “set password for ‘root’@’127.0.0.1’ password(‘new_pwd’);” 创建用户 mysql -u root -p -e “grant usage on . to ‘username’@’localhost’ identified by ‘password’;” 授权 mysql -u root -p -e “grant selecr/all on . to ‘username’@’localhost’;” 看表结构 describe tablename;show create tablename; \\G表示数据以行显示 创建数据库时指定字符集 create database databasenamecharacter set utf8 创建数据库时指定默认校对方式 rollate utf8_general_ci; 备份 \\表示告诉shell下一行还有 path表示路径 mysqldump –user=’username’ -p \\databasename [tablename] &gt; path 恢复备份 mysql –user=’username’ -p \\databasename [tablename] &lt; path 复制表结构 create table tablename like another_tablename; 复制表数据 insert into tablename select * from another_tablename; 修改表 alter table tablename changes 增加列 alter table tablename add column 列名 类型 索引 [after 列]; 删除列 alter table tablename drop column 列名; 修改列名 alter table tablename change column old_column new_column type; default b ‘默认值’ 表示设置默认值 修改/删除默认值 alter table tablenamealter columnname set/drop default []; 查看表的auto_increment值 select auto_increment from information_schema.tables where table_name = ‘tablename’; 修改auto_increment值 alter table tablename auto_increment = X; 修改/移动表 rename table tablename to tablename; 更改数据排列 alter table tablenameorder by ..; 在select 之前 加上explain 可查mysql根据什么 [索引] 查找数据 增加索引 alter table tablenameadd index indexname (column_name,[column_name]); 模糊搜索列名 show columns from tablename like ‘%xx%’; 插入数据(忽略错误) insert ignore into tablename select … from tablename; 显示错误 show warnings; 替换数据(replace) replace into tablename(column..) values(..) replacet 替换的时候，如果有unique索引，是先删除原有的列，在插入新列，若无指定值，会插入默认值，若无索引，则是新插入列 数据插入的优先级(写在 insert 和 into 之间)insert 优先于 select 降低insert的优先级 (low_priority) 延迟插入 (delayed) MySQL5.5.6后不提倡用了 提升insert的优先级 (high_priority) 插入时处理重复数据1234insert into tablename select .. from tablename ...on duplicate key update ... 查询 1234select */column from tablename where column [in / is null / = / like &apos;%/_x&apos; ]order by column asc/ desclimit start,end; MySQL 先按where字句获取所有数据，并在幕后将结果存放于临时表，在按order by 排序，最后根据limit获取特定序列的数据 正则匹配123select * from tablename where column regexp [binary] &apos;...&apos;;binary 表示区分大小写 更新语句 ,update单表时可用order by 和 limit1234update tablename set column = .. where conditionorder by columnlimit row_count; 删除语句 ,delete单表时可用order by 和 limit1234delete from tablename where conditionorder by columnlimit row_count; 连删 (using 声明连接方式) using join方式1234567891011delete from table [, table]using table [,...][where condition];example：delete from humans, prize_winnersusing humans left join prize_winnerson humans.human_id = prize_winners.human_idwhere name_first = &apos;Elena&apos;and name_last = &apos;Bokova&apos;and email_address like &apos;%yahoo.com&apos;; 连表时两表有同列名 join using方式1234select * from tablejoin table using(column)where condition; 性能比较 使用benchmark()函数 内置函数拼接字符串 concat(column,what,column) 拼接字符串 concat_ws(what,column,column…) 判断NULL ifnull(column, default) 转换小写 lower() | lcase() 转换大写 upper() | ucase() 避免识别出错 quote() 单引号包围后输出，转移字符前加 \\ 去开头空格 ltrim() 去尾部空格 rtrim() trim() 不止可以去除两段空格，还可以去除别的字符如：” trim(both ‘字符’ from column) trim() 默认是both，去除一端可指定leading或者trailing 左端填充 lpad(str,len,padstr) 右端填充 rpad(str,len,padstr) 填充空格 space(N) MySQL 是从1开始的，而不是0 左截取 left(str,len) 右截取 left(str,len) 从右往左数 截取字符 substring(str,pos,len) 或者 mid(str,pos,len) 截取元素 substring_index(str,delim,count) locate(substr,column) 查找字串位置，返回字串出现的首位置 查找字串 position(substr in coliumn) 判断 if(what, yes, no) 获取字符长度 char_length(str) | character_length(str) 获取位数 bit_length(str) 比较函数 strcmp(expr1,expr2) 一致返回0 FULLTEXT索引模糊搜索 match(column) against(str) 替换函数 insert(column,pos,len,newstr) 第三个参数表示多少个字符被替换 类型转换 cast(column AS type) | convert(column,type) | convert(column using utf8) 压缩字符串，安装MySQL需带上压缩库(zlib) compress(str) 解压缩 uncompress(column) 时间函数当前日期和时间 now() | current_timestamp() | localtimestamp() | localtime() 暂停秒数 sleep(N) 获取自身被执行的时间点 systdate() 主要用于非常复杂的sql语句，或者存储过程和触发器之中 获取当前日期 curdate() 获取当前时间 curtime() 获取当前时间戳 unix_timestamp() 抽取日期 date(column) 抽取时间 time(column) 抽取年 year(column) 抽取月 month(column) 抽取日 day(column) 抽取小时 hour(column) 抽取分 minute(column) 抽取秒 second(column) 获取指定日期的月份 monthame() 获取指定日期的星期 dayame() 抽取函数 extract(unit FROM date) lntervar 返回格式 day dd day_hour ‘dd hh’ day_microsecond ‘dd.nn’ day_minute ‘dd hh:mm’ day_second ‘dd hh:mm:ss’ hour hh hour_microsecond ‘hh.nn’ hour_minute ‘hh:mm’ hour_second ‘hh:mm:ss’ microsecond nn minute mm minute_microsecond ‘mm.nn’ minute_second ‘mm:ss’ month mm quarter qq second ss second_microsecond ‘ss.nn’ week ww year yy year_month ‘yy-mm’ 格式化日期 date_format(date,format) 格式化时间 time_format(time,format) 代码 描述 结果 %a 简写的周几 (Sun…Sat) %b 简写的月份名字 (Jan…Dec) %c 月份(数字形式) (1…12) %d 一个月中的哪一天(数字形式) (00…31) %D 一个月中的哪一天(带有英文后缀) (1st,2nd,3rd…) %e 一个月中的哪一天(数字形式) (0…31) %f 毫秒(数字形式) (000000…999999) %h 小时 (01…12) %H 小时 (00…23) %i 分钟 (00…59) %I 小时 (01…12) %j 一年中的哪一天 (001…366) %k 小时 (0…23) %l 小时 (1…12) %m 月份 (01….12) %M 月份名字 (January….December) %p AM或者PM AM or PM %r 时间，12小时制 (hh:mm:ss[A P]M) %s 秒 (00…59) %S 秒 (00…59) %T 时间，24小时制 (hh:mm:ss) %u 一年中的第几周(以周一为一周的第一天) (0…52) %U 一年中的第几周(以周日为一周的第一天) (0…52) %v 一年中的第几周(以周一为一周的第一天，与%x一起使用) (1…53) %V 一年中的第几周(以周日为一周的第一天，与%X一起使用) (1…53) %w 一周中的哪一天 (0=Sunday…6=Saturday) %W 周几 (Sunday….Saturday) %x 某一周所属的年份(以周一为一周的第一天,4位数字形式，与%v一起使用) (yyyy) %X 某一周所属的年份(以周日为一周的第一天,4位数字形式，与%V一起使用) (yyyy) %y 年份(两位数字形式) (yy) %Y 年份(四位数字形式) (yyyy) %% 字面的%% ‘%’ 获取标准的日期格式 get_format({DATE|TIME|DATETIME}, {‘EUR’|’USA’|’JIS’|’ISO’|’INTERNAL’}) EUR 代表欧洲 USA 代表美国 JIS 代表日本工业标准 ISO 代表ISO 9075标准 INTERNAL 代表没有标点符号的时间格式 时区时间转换 convert_tz(datetime,from_tz,to_tz) 日期增加 date_add(date,interval expr unit) 日期缩减 date_sub(date,interval expr unit) 时间换算秒 time_to_sec(time) 秒换算时间 sec_to_time(seconds) 日期加减函数 period_add(P,N) 参数为字符串 日期比较 datediff(expr1,expr2) 日期比较 timediff(expr1,expr2) 聚合函数计算总数 count(expr1) 按组分 group by 求组分的同时求总数，可在group by 中加入 with rollup 求和 sum(expr) 求平均 avg([DISTINCT] expr) 求最大 max(expr) 求最小 min(expr) 组拼接 group_concat(expr) 四舍五入 round(X,D) 下舍入 floor(X) 上舍入 ceiling(X) 去掉小数 truncate(X,D) 绝对值 abs(X) 判断正负 sign(X) 设置用户自定义变量 set @name = expr; 数据库管理查看用户权限1show grants for &apos;username&apos;; 结果中的 . 是指授权使用所有数据库和所有表, ‘username’@’%’中主机是通配符 % ，无论何时都应该指定主机。 删除用户账号 drop user ‘username’@’..’, 删除前先查看mysql数据库的user表1select User,Host from mysql.user where User like &apos;%username%&apos;; 授权 grant privilege [(column…)] on database.table to ‘username’@’..’ 权限 描述 all [privileges] 授予所有基本的权限，但不包括grant option alter 允许使用alter table 语句，但得现有create和insert权限，如果想重命名一个表。还得现有drop权限，这里有一个安全隐患：用户可以通过对表改名来获得访问权 alter routine 允许用户账号更改或删除存储过程，即允许使用alter function、alter procedure、drop function和drop procedure语句 create 允许使用create table 语句。如果想定义索引，还需要index权限 create routine 允许用户账号创建存储过程，即允许使用create function 和 create procedure 语句。并且，用户账号对自己创建的过程拥有alter routine权限 create temporary tables 允许使用create temporary tables 语句 create user 允许用户账号执行以下用户账号管理语句：create user、raname user、revoke all privileges和drop user create view 允许使用create view 语句 delete 允许使用delete语句 drop 允许使用drop table 和 truncate语句 event 允许用户账号为事件调度器创建事件，即允许使用create event、alter event 和 drop event 语句 execute 允许执行存储过程，即允许使用execute语句 file 允许使用select … into outfile 和 load data infile语句来导出数据到文件系统，或从文件系统导入数据。还有一个安全隐患。可通过secure_file_priv 变量来限制指定目录 index 允许使用create index 和 drop index 语句 insert 允许使用insert语句。这是执行analyze table、optimize table 和 repair table 语句的前提条件 lock tables 允许使用lock tables 语句，但用户必须先对表有select权限 process 允许使用show processlist和show endine语句 reload 允许使用flush 语句 replication client 允许用户查询主从服务器的状态信息，即允许使用show master status、show slave status 和 show binary logs语句 replication slave 进行从服务器复制时，需要此权限，它将允许读取主服务器的二进制日志事件 select 允许使用select 语句 show databases 允许使用show databases 语句来查看所有数据库，包括那些没有权限的数据库 show view 允许使用show create view 语句 shutdown 允许使用mysqladmin工具的shutdown选项 super 允许使用change master to、kill、purge binary logs、set global语句，以及mysqladmmin 工具的debug选项 trigger 允许用户账号创建或删除触发器，即允许使用create trigger 和 drop trigger 语句 update 允许使用update 语句 usage 可用于创建无权限的用户，或在不影响用户现有权限的情况下修改某某方面的属性 移除权限 revoke privileges on database.table from ‘username’@’..’; 获取会话标识 需process权限 show processlist; 结束会话 id为获取会话的id 需super权限 kill id; 强迫用户修改密码 alter user ‘username’@’localhost’ password expire; 修改密码123set password for &apos;username&apos;@&apos;localhost&apos; = &apos;encrpt_password&apos;;或者set password for &apos;username&apos;@&apos;localhost&apos; = password(&apos;password&apos;); 重置root密码123456新建文本文件，输入以下内容UPDATE mysql.user SET Password=PASSWORD(&apos;new_pwd&apos;) WHERE User=&apos;root&apos;;FLUSH PRIVILEGES;将该文件起名为rt-reset.sql，并放在受保护的目录，然后用 --init-file，启动mysql：mysqld_sefe --init-file=/root/rt-reset.sql &amp;改完之后，删除rt-reset.sql 用户改名 需create user和对mysql数据库update 权限 rename user ‘username’@’localhost’ to ‘newusername’@’localhost’; 创建角色 create role ‘role_name’; 授权给角色 grant privilege on databases.table to ‘rolename’@’localhost’; 给用户赋予角色 grant ‘role_name’ to ‘username’@’localhost’; 用户登陆后设定角色 set role ‘rolename’; 用户脱离角色 set role none;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.huizhe.zxy/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.huizhe.zxy/tags/MySQL/"}]},{"title":"python爬虫学习","slug":"python-crawler","date":"2017-10-16T06:23:40.000Z","updated":"2018-07-27T08:28:17.278Z","comments":true,"path":"python-crawler/","link":"","permalink":"https://www.huizhe.zxy/python-crawler/","excerpt":"python的爬虫相对来说，会比较容易上手一点，采用官方和第三方的类库实现 本篇文章采用requests，BeautifulSoup这两个第三方库来编写爬虫 并采用jieba分词，分析文本中的关键词及其权重","text":"python的爬虫相对来说，会比较容易上手一点，采用官方和第三方的类库实现 本篇文章采用requests，BeautifulSoup这两个第三方库来编写爬虫 并采用jieba分词，分析文本中的关键词及其权重 网页下载器1234import requestsresponse = requests.get(url)if response.status_code == 200 return response.content 在这里使用了http的get方式，传入要扒的网址，然后判断响应码 若返回200，则响应成功，返回html的内容 requests学习 网页分析器123import BeautifulSoupsoup = BeautifulSoup(html,'html.parser')print(soup.prettify()) 这里的html为上文中的response.content，并采用html_parser解析html 这里只是简单地打印了soup的内容而已 附上BeautifulSoup文档和一篇不错的博文 jieba分词地使用1234import jiebatags = jieba.analyse.extract_tags(sentence , topK=20, withWeight=True)for item in tags: print(item[0] + '\\t' + str(int(item[1] * 1000))) 此处使用jieba分词的基于TF-IDF关键词抽取 sentence 为待提取的文本 topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20 withWeight 为是否一并返回关键词权重值，默认值为 False 附上jieba分词github网址本文只是初步涉及python爬虫的学习，后续将继续学习，进阶python爬虫学习附上一篇实战的代码","categories":[{"name":"python","slug":"python","permalink":"https://www.huizhe.zxy/categories/python/"}],"tags":[{"name":"crawler","slug":"crawler","permalink":"https://www.huizhe.zxy/tags/crawler/"},{"name":"python","slug":"python","permalink":"https://www.huizhe.zxy/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-12T08:29:41.000Z","updated":"2018-07-27T08:20:09.452Z","comments":true,"path":"hello-world/","link":"","permalink":"https://www.huizhe.zxy/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"start","slug":"start","permalink":"https://www.huizhe.zxy/categories/start/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.huizhe.zxy/tags/hexo/"}]}]}