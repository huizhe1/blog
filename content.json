{"meta":{"title":"Huizhe","subtitle":"记录一些学习心得","description":"命运常以痛为吻，我们仍要报之以歌，情深义重","author":"灰者","url":"https://www.huizhe.xyz"},"pages":[{"title":"","date":"2018-07-27T08:55:31.363Z","updated":"2017-10-12T09:42:54.000Z","comments":true,"path":"404.html","permalink":"https://www.huizhe.xyz/404.html","excerpt":"","text":"404页面 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num 暂时未能找到您查找的页面 可能输入的网址错误或此页面不存在 秒后自动跳转到主页"},{"title":"about","date":"2017-10-09T13:12:02.000Z","updated":"2018-07-27T09:29:10.723Z","comments":true,"path":"about/index.html","permalink":"https://www.huizhe.xyz/about/index.html","excerpt":"","text":"关于我—huizhe2015 - 2019就读于广东韶关学院，专业是软件工程在校期间，加入网园资讯工作室 编程部，主要职责是利用ASP.NET完成学校官网的制作及修改课余时间，学习利用PHP，完成一些项目的开发，主要有大创项目，成绩查询和课程系统。目前，在学习JAVA开发，主要学习三大框架以及Redis集群。 联系方式email: a22783276@163.com"},{"title":"categories","date":"2017-10-09T14:46:33.000Z","updated":"2017-10-09T14:47:10.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.huizhe.xyz/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-09T14:47:48.000Z","updated":"2017-10-09T14:48:02.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.huizhe.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hibernate之Criteria","slug":"hibernate","date":"2018-09-03T02:13:47.000Z","updated":"2018-09-03T03:02:11.555Z","comments":true,"path":"hibernate/","link":"","permalink":"https://www.huizhe.xyz/hibernate/","excerpt":"","text":"Hibernate 框架Hibernate是一种ORM框架，全称为 Object_Relative DateBase-Mapping，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象！ ORM 概述- O 代表的是 Object - R 代表的是 Relative - M 代表的是 Mapping - ORM-&gt; 对象关系映射，ORM关注的是对象与数据库中列的关系 Hibernate 入门- 引入 jar 开发的包 - 配置相关的 XML 文件 - 熟悉 API 当然，如果你使用的是 IDEA 进行开发的话，前面两步我们可以进行简化IntelliJ IDEA Hibernate 从入门到填坑参考这篇文章，可以快速的配置相关的XML文件，并创建相关的对象和对象映射 CriteriaCriteria 查询是以元模型的概念为基础的，元模型是为具体持久化单元的受管实体定义的，这些实体可以是实体类，嵌入类或者映射的父类。但自 Hibernate 5.2 版本之后，org.hibernate.Criteria 不推荐使用API​​的大多数方法，新开发的重点是JPA javax.persistence.criteria.CriteriaQueryAPI 创建 Criteria1Criteria cri = session.createCriteria(EntityClass.class); 应被替换为12CriteriaBuilder crb = s.getCriteriaBuilder();CriteriaQuery&lt;EntityClass&gt; c = crb.createQuery(EntityClass.class); Criteria 条件查询1cri.add(Restrictions.like(\"column\", \"Fritz%\") ) 应被替换为1234// 指定根条件Root&lt;CstCustomerEntity&gt; root = c.from(EntityClass.class);c.select(root);c.where(crb.like(root.get(\"column\"),\"%get%\")); Criteria 排序1cri.addOrder(Order.desc(\"column\")); 应被替换为12// 指定根条件 c.orderBy(crb.desc(root.get(\"column\"))); 分页12cri.setFirstResult(0); cri.setMaxResults(2); 应被替换为123Query&lt;EntityClass&gt; query = s.createQuery(c);query.setFirstResult(0);query.setMaxResults(2); 聚合函数1cri.setProjection(Projections.rowCount()); 应被替换为123456// 获取 Criteria 对象CriteriaBuilder crb = s.getCriteriaBuilder();CriteriaQuery&lt;Long&gt; c = crb.createQuery(Long.class);// 指定根条件Root&lt;EntityClass&gt; root = c.from(EntityClass.class);c.select(crb.count(root)); 源码附上所有源码参考一下 数据库12345678910CREATE TABLE `cst_customer` ( `cust__id` bigint(32) NOT NULL AUTO_INCREMENT, `cust_name` varchar(32) DEFAULT NULL, `cust_source` varchar(32) DEFAULT NULL, `cust_industry` varchar(32) DEFAULT NULL, `cust_level` varchar(32) DEFAULT NULL, `cust_address` varchar(128) DEFAULT NULL, `cust_phone` varchar(64) DEFAULT NULL, PRIMARY KEY (`cust__id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; hibernate.cfg.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/itcast&lt;/property&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 2. hibernate 的可选配置--&gt; &lt;!-- 是否显示hibernate 生成的sql 语句--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--是否使用格式化输出sql语句到控制台--&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!-- 配置 hibernate 采用何种方式生成DDL语句--&gt; &lt;!-- update 表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 设置hibernnate 连接池的提供商--&gt; &lt;property name=\"connection.provider_class\"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接最少数目--&gt; &lt;property name=\"c3p0.min_size\"&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目--&gt; &lt;property name=\"c3p0.max_size\"&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间，以毫秒为单位， 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间， 就会从连接池中清除--&gt; &lt;property name=\"c3p0.timeout\"&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt; &lt;property name=\"c3p0.idle_test_period\"&gt;3000&lt;/property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 3. 隐射文件的位置--&gt; &lt;mapping resource=\"com/huizhe/domain/CstCustomerEntity.hbm.xml\"/&gt; &lt;mapping class=\"com.huizhe.domain.CstCustomerEntity\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; CstCustomerEntity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.huizhe.domain;import javax.persistence.*;import java.util.Objects;@Entity@Table(name = \"cst_customer\", schema = \"itcast\", catalog = \"\")public class CstCustomerEntity &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; public CstCustomerEntity() &#123; &#125; public CstCustomerEntity(Long custId, String custName) &#123; this.custId = custId; this.custName = custName; &#125; @Override public String toString() &#123; return \"CstCustomerEntity&#123;\" + \"custId=\" + custId + \", custName='\" + custName + '\\'' + \", custSource='\" + custSource + '\\'' + \", custIndustry='\" + custIndustry + '\\'' + \", custLevel='\" + custLevel + '\\'' + \", custAddress='\" + custAddress + '\\'' + \", custPhone='\" + custPhone + '\\'' + '&#125;'; &#125; @Id @Column(name = \"cust_id\", nullable = false) public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; @Basic @Column(name = \"cust_name\", nullable = true, length = 32) public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; @Basic @Column(name = \"cust_source\", nullable = true, length = 32) public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; @Basic @Column(name = \"cust_industry\", nullable = true, length = 32) public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; @Basic @Column(name = \"cust_level\", nullable = true, length = 32) public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; @Basic @Column(name = \"cust_address\", nullable = true, length = 128) public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; @Basic @Column(name = \"cust_phone\", nullable = true, length = 64) public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; CstCustomerEntity that = (CstCustomerEntity) o; return custId == that.custId &amp;&amp; Objects.equals(custName, that.custName) &amp;&amp; Objects.equals(custSource, that.custSource) &amp;&amp; Objects.equals(custIndustry, that.custIndustry) &amp;&amp; Objects.equals(custLevel, that.custLevel) &amp;&amp; Objects.equals(custAddress, that.custAddress) &amp;&amp; Objects.equals(custPhone, that.custPhone); &#125; @Override public int hashCode() &#123; return Objects.hash(custId, custName, custSource, custIndustry, custLevel, custAddress, custPhone); &#125;&#125; CstCustomerEntity.hbm.xml12345678910111213141516&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.huizhe.domain.CstCustomerEntity\" table=\"cst_customer\" schema=\"itcast\"&gt; &lt;id name=\"custId\" column=\"cust_id\"/&gt; &lt;property name=\"custName\" column=\"cust_name\"/&gt; &lt;property name=\"custSource\" column=\"cust_source\"/&gt; &lt;property name=\"custIndustry\" column=\"cust_industry\"/&gt; &lt;property name=\"custLevel\" column=\"cust_level\"/&gt; &lt;property name=\"custAddress\" column=\"cust_address\"/&gt; &lt;property name=\"custPhone\" column=\"cust_phone\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; HibernateUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.huizhe.Util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static SessionFactory factory; private static ThreadLocal&lt;Session&gt; tl = new ThreadLocal&lt;&gt;(); static&#123; try &#123; Configuration cfg =new Configuration(); cfg.configure(); factory = cfg.buildSessionFactory(); &#125; catch ( ExceptionInInitializerError e) &#123; throw new ExceptionInInitializerError(\"初始化SessionFactory 失败，请检查配置文件\"); &#125; &#125; /** * 获取一个新的Session对象 * 只要使用 OpenSession 方法，每次得到的都是一个新的session * @return */ public static Session openSession() &#123; //Session s = tl.get(); //if (s==null) &#123; // tl.set(factory.openSession()); //&#125; //s = tl.get(); //return s; return factory.openSession(); &#125; /** * 从当前线程上获取Session对象 * 只有配置了把 session 和线程绑定之后，才能使用此方法，否则返回值是 null * @return */ public static Session getCurrentSession() &#123; return factory.getCurrentSession(); &#125;&#125; Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.huizhe.test;import com.huizhe.Util.HibernateUtil;import com.huizhe.domain.CstCustomerEntity;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.Transaction;import org.hibernate.criterion.DetachedCriteria;import org.hibernate.criterion.Restrictions;import org.hibernate.query.Query;import org.junit.Test;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Root;import java.util.List;/** * QBC 全称： Query By Criteria * 它是一种更加面向对象的查询方式，它把生成语句的过程全都融入到方式之中 */public class HibernateQBC &#123; @Test public void test1() &#123; // 基本查询 Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); // 获取 Criteria 对象 CriteriaQuery&lt;CstCustomerEntity&gt; c = s.getCriteriaBuilder().createQuery(CstCustomerEntity.class); // 指定根条件 c.from(CstCustomerEntity.class); List&lt;CstCustomerEntity&gt; list = s.createQuery(c).getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit(); &#125; @Test public void test2() &#123; // 条件查询 Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); // 获取 Criteria 对象 CriteriaBuilder crb = s.getCriteriaBuilder(); CriteriaQuery&lt;CstCustomerEntity&gt; c = crb.createQuery(CstCustomerEntity.class); // 指定根条件 Root&lt;CstCustomerEntity&gt; root = c.from(CstCustomerEntity.class); c.select(root); c.where(crb.like(root.get(\"custName\"),\"%get%\")); List&lt;CstCustomerEntity&gt; list = s.createQuery(c).getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit(); &#125; @Test public void test3() &#123; // 排序查询 Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); // 获取 Criteria 对象 CriteriaBuilder crb = s.getCriteriaBuilder(); CriteriaQuery&lt;CstCustomerEntity&gt; c = crb.createQuery(CstCustomerEntity.class); // 指定根条件 Root&lt;CstCustomerEntity&gt; root = c.from(CstCustomerEntity.class); c.select(root); c.orderBy(crb.desc(root.get(\"custId\"))); List&lt;CstCustomerEntity&gt; list = s.createQuery(c).getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit(); &#125; @Test public void test4() &#123; // 分页查询 Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); // 获取 Criteria 对象 CriteriaBuilder crb = s.getCriteriaBuilder(); CriteriaQuery&lt;CstCustomerEntity&gt; c = crb.createQuery(CstCustomerEntity.class); // 指定根条件 Root&lt;CstCustomerEntity&gt; root = c.from(CstCustomerEntity.class); c.select(root); // 设置分页 Query&lt;CstCustomerEntity&gt; query = s.createQuery(c); query.setFirstResult(0); query.setMaxResults(2); List&lt;CstCustomerEntity&gt; list = query.getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit(); &#125; @Test public void test5() &#123; // 统计查询 Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); // 获取 Criteria 对象 CriteriaBuilder crb = s.getCriteriaBuilder(); CriteriaQuery&lt;Long&gt; c = crb.createQuery(Long.class); // 指定根条件 Root&lt;CstCustomerEntity&gt; root = c.from(CstCustomerEntity.class); c.select(crb.count(root)); Query&lt;Long&gt; query = s.createQuery(c); System.out.println(query.getSingleResult()); tx.commit(); &#125; @Test public void test6() &#123; // 离线查询 // 1. 获取离线对象，不需要Session DetachedCriteria dc = DetachedCriteria.forClass(CstCustomerEntity.class); // 2. 封装查询对象 dc.add(Restrictions.eq(\"custId\", 2L)); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Criteria c = dc.getExecutableCriteria(s); List&lt;CstCustomerEntity&gt; list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit(); &#125;&#125; 注意这里只是用于练习的代码，并非是真实代码，正式产出时，应遵守 JPA2 规范 和 使用元模型，使得查询更加类型安全等。 参考 Hibernate入门 IntelliJ IDEA Hibernate 从入门到填坑 Hibernate 5 - Criteria查询示例 java-jpa-criteriaBuilder使用入门","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"记一次踩坑过程—非Maven项目","slug":"javaProject","date":"2018-08-19T08:48:22.000Z","updated":"2018-08-19T09:25:31.604Z","comments":true,"path":"javaProject/","link":"","permalink":"https://www.huizhe.xyz/javaProject/","excerpt":"","text":"因为我的博客系统是采用 Hexo 搭配 Next 主题，是纯静态页面的，所有就想着把博客用 java 写成一个动态页面，既可以当作是练习，也算是自己对这一个多月来的实践。所以上周就开始动工，先把几个页面提取出来了，先提取了，后面的就是数据绑定的事了。所以再提取完页面之后，再找了个后台管理模板，对博文等等进行处理。附上后台管理模板 AdminLTE 创建项目这里有个博文比较详细，前两天如果照着这个博文来，可能就不会中一些招了吧IDea发布JavaWeb项目 详解一 照着这个打，就可以完成入门的 Hello World 的一个JSP页面了。 Servlet 定义：其实 Servlet 是遵循 Servlet 开发的一个java类。 Servlet 是由服务器调用的，运行在 服务器 端 作用： 处理浏览器带来的HTTP请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互。使用 Servlet ，我们就不用特意用一个JSP页面，去接受http请求并相应。 Servlet 是非线程安全的，涉及到变量共享的时候，要记得加锁或者采用同步方法。 HTTP 协议 是计算机通过网络进行通信的规则 是一个基于请求与响应，无状态，应用层的协议 常基于 TCP/IP 协议传输数据 HTTP 请求报文一个 HTTP 请求报文由请求行、请求头部、空行和请求数据 4个部分组成。 请求行 分为三个部分 请求方法HTTP/1.1 定义的请求方法由8 种： GET POST PUT DELETE PATCH HEAD OPTIONS TRACE最常使用的是 GET 和 POST 方法。RESTful 接口的话，一般会使用到 GET、POST、DELETE、PUT/PATCH 请求地址URL： 统一资源定位符 Uniform Resource Locator URL， 是一种自愿位置的抽象唯一识别方法。组成： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;端口为80时，可省略，https协议使用的是443端口 协议版本格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 请求头部 请求头部为请求报文添加了一些附加信息，由 键/值 对组成，每行一对，用 : 分隔 常见请求头： 请求头 说明 Host 接受请求的服务器地址 User-Agent 发送请求的应用程序名称 Connection 指定与连接相关的属性 Accept-Charset 通知服务端可以发送的编码格式 Accept-Encoding 通知服务端可以发送的数据压缩格式 Accept-Language 通知服务端可以发送的语言 Cookie 客户机通过这个头可以向服务器带数据 空行，表示请求头部结束 请求数据（可选部分） HTTP 响应报文HTTP 响应报文主要由 状态行、响应头部、空行以及响应数据组成。 状态行 协议版本协议版本于请求报文的一致 状态码状态码为3位数字 状态码 状态码描述 1xx 指示信息–表示请求已接收，继续处理。 2xx 成功–表示请求已被成功接收、理解、接受。 3xx 重定向–要完成请求必须进行更进一步的操作。 4xx 客户端错误–请求有语法错误或请求无法实现。 5xx 服务器端错误–服务器未能实现合法的请求。 状态码描述 常见状态码 状态码 说明 200 响应成功 302 跳转，跳转地址由响应头种的Location属性指定 400 客户端请求有语法错误，不能被服务器识别 403 服务器接受到请求，但是拒绝提供服务 404 请求资源不存在 500 服务器内部错误 响应头部 与请求头部类似，附上常见响应头部信息 响应头 说明 Server 服务器应用程序软件的名称和版本 Content-Type 响应正文的类型 Content-Length 响应正文长度 Content-Charset 响应正文使用的编码 Content-Encoding 响应正文使用的数据压缩格式 Content-Language 响应正文使用的语言 响应数据 用于存放需要返回给客户端的数据信息 HttpServletRequest 对象HttpServletRequest 对象代表 客户端的请求，http请求头部中的所有信息都封装在这个对象中。 获取浏览器信息 getRequestURL方法返回客户端发出请求时的完整URL getRequestURI方法返回请求行中的资源名部分 getQueryString 方法返回请求行中的参数部分 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头 getRemoteAddr方法返回发出请求的客户机的IP地址 getRemoteHost方法返回发出请求的客户机的完整主机名 getRemotePort方法返回客户机所使用的网络端口号 getLocalAddr方法返回WEB服务器的IP地址 getLocalName方法返回WEB服务器的主机名 获取浏览器请求头 getHeader方法 getHeaders方法 getHeaderNames方法 获取浏览器请求参数 getParameter方法 getParameterValues（String name）方法 getParameterNames方法 getParameterMap方法 HttpServletResponse 对象HttpServletResponse 对象代表 客户端的响应，这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法 负责向客户端(浏览器)发送数据 getOutputStream() getWriter() 负责向客户端(浏览器)发送响应头 addDateHeader(String s, long l) addHeader(String name, String value) addIntHeader(String name, int value) containsHeader(String name) 负责向客户端(浏览器)发送响应状态码 setStatus(int sc) 响应状态码的常量1234567891011121314151617181920212223242526272829303132333435363738394041int SC_CONTINUE = 100;int SC_SWITCHING_PROTOCOLS = 101;int SC_OK = 200;int SC_CREATED = 201;int SC_ACCEPTED = 202;int SC_NON_AUTHORITATIVE_INFORMATION = 203;int SC_NO_CONTENT = 204;int SC_RESET_CONTENT = 205;int SC_PARTIAL_CONTENT = 206;int SC_MULTIPLE_CHOICES = 300;int SC_MOVED_PERMANENTLY = 301;int SC_MOVED_TEMPORARILY = 302;int SC_FOUND = 302;int SC_SEE_OTHER = 303;int SC_NOT_MODIFIED = 304;int SC_USE_PROXY = 305;int SC_TEMPORARY_REDIRECT = 307;int SC_BAD_REQUEST = 400;int SC_UNAUTHORIZED = 401;int SC_PAYMENT_REQUIRED = 402;int SC_FORBIDDEN = 403;int SC_NOT_FOUND = 404;int SC_METHOD_NOT_ALLOWED = 405;int SC_NOT_ACCEPTABLE = 406;int SC_PROXY_AUTHENTICATION_REQUIRED = 407;int SC_REQUEST_TIMEOUT = 408;int SC_CONFLICT = 409;int SC_GONE = 410;int SC_LENGTH_REQUIRED = 411;int SC_PRECONDITION_FAILED = 412;int SC_REQUEST_ENTITY_TOO_LARGE = 413;int SC_REQUEST_URI_TOO_LONG = 414;int SC_UNSUPPORTED_MEDIA_TYPE = 415;int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;int SC_EXPECTATION_FAILED = 417;int SC_INTERNAL_SERVER_ERROR = 500;int SC_NOT_IMPLEMENTED = 501;int SC_BAD_GATEWAY = 502;int SC_SERVICE_UNAVAILABLE = 503;int SC_GATEWAY_TIMEOUT = 504;int SC_HTTP_VERSION_NOT_SUPPORTED = 505; 转发和重定向 转发：转发是由服务器进行跳转的。浏览器的地址栏是没有发生变化的。即转发是对浏览器透明的。实现转发只是一次 http 请求，一次转发中的 request 和 response 对象都是同一个 重定向：重定向是由浏览器进行跳转的。浏览器的地址是会发生变化的。由浏览器进行页面跳转实现 重定向 会发出两个 htpp 请求，request 域对象是无效的，因为它不是同一个request对象 转发和重定向区别： 用法不同给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 范围不同转发是服务器跳转只能去往当前web应用的资源重定向是服务器跳转，可以去往任何的资源 传递的类型不同转发的request 对象可以传递各种类型的数据，包括对象重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 请求是不一样的 转发是带着转发前的请求参数的 重定向是新的请求 Cookie指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）Cookie 总是保存在客户端中，按在客户端的存储位置，分为内存Cookie 和硬盘Cookie 内存 Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的 硬盘 Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的 Cookie 流程 浏览器访问服务器，如果服务器需要记录该用户的状态，就使用response向浏览器发送一个Cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同Cookie一同交给服务器。 Cookie API Cookie类用于创建一个Cookie对象 response接口中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段 request接口中定义了一个getCookies方法，它用于获取客户端提交的Cookie 常用的Cookie方法： public Cookie(String name,String value) setValue与getValue方法 setMaxAge与getMaxAge方法 设置Cookie 的有效性 setPath与getPath方法 设置Cookie成仅某个文件可用 setDomain与getDomain方法 设置Cookie 域名 getName方法 Session会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制。是另一种记录浏览器状态的机制。不同的是Cookie保存在浏览器中，Session保存在服务器中。 Session API long getCreationTime();【获取Session被创建时间】 String getId();【获取Session的id】 long getLastAccessedTime();【返回Session最后活跃的时间】 ServletContext getServletContext();【获取ServletContext对象】 void setMaxInactiveInterval(int var1);【设置Session超时时间】 int getMaxInactiveInterval();【获取Session超时时间】 Object getAttribute(String var1);【获取Session属性】 Enumeration getAttributeNames();【获取Session所有的属性名】 void setAttribute(String var1, Object var2);【设置Session属性】 void removeAttribute(String var1);【移除Session属性】 void invalidate();【销毁该Session】 boolean isNew();【该Session是否为新的】 附上 Servlet 学习资源 Servlet第一篇【介绍Servlet、HTTP协议、WEB目录结构、编写入门Servlet程序、Servlet生命周期】 Servlet第二篇【Servlet调用图、Servlet细节、ServletConfig、ServletContext】 Servlet第三篇【request和response简介、response的常见应用】 Servlet第四篇【request对象常用方法、应用】 Servlet第五篇【介绍会话技术、Cookie的API、详解、应用】 Servlet第六篇【Session介绍、API、生命周期、应用、与Cookie区别】 Cookie 和 Session 的区别 从存储方式上比较快 Cookie 只能存储字符串，存储非ASCII字符串还需要对其编码 Session 可以存储任何类型的数据 从隐私安全上比较 Cookie 存储在浏览器中，对客户端是可见的，信息容易泄露 Session 存储在服务器中，对客户端是透明的 从有效期上比较 Cookie 存储在硬盘中，只需要设置maxAge为大的正数，关闭浏览器，Cookie 还是存在、 Session 存储在服务器中，设置了 maxInactiveInterval 属性来确定Session的有效期，并且Session依赖于JSESSIONID的 Cookie，Cookie默认的maxAge属性值为-1 从对服务器的负担比较 Session 保存在服务器中，每个用户都会产生一个Session，如果并发访问的用户非常多，是不能使用 Session 的，Session 会消耗大量的内存 Cookie 是保存在和客户端的。不占用服务器资源 从浏览器的支持上比较 如果浏览器禁用了Cookie，那么Cookie 是无用的 如果浏览器禁用了Cookie，Session 可以通过URL地址重写等技术来进行会话跟踪 从跨域名上比较 Cookie 可以设置domain属性来实现跨域名 Session 只在当前的域名内有效，不可跨域名 详细区别 Cookie 与 Session 的区别 JAVA EE 架构这里使用的是 JAVA EE 三层架构，具体可以看上一篇文章 JAVA EE 软件开发体系架构 配置 TomcatIdea 配置 Tomcat ，可以参考文章开头的博客进行设置。 Artifacts 项目部署这里部署直接参考以下博文理解 IntelliJ IDEA 的项目配置和Web部署 提取了博文的注意点:实际上，当你点击运行tomcat时，默认就开始做以下事情： 编译，IDEA在保存/自动保存后不会做编译，不像Eclipse的保存即编译，因此在运行server前会做一次编译。编译后class文件存放在指定的项目编译输出目录下 根据artifact中的设定对目录结构进行创建 拷贝web资源的根目录下的所有文件到artifact的目录下 拷贝编译输出目录下的classes目录到artifact下的WEB-INF下 拷贝lib目录下所需的jar包到artifact下的WEB_INF下 运行server，运行成功后，如有需要，会自动打开浏览器访问指定url 踩的几个坑因为是刚入门 Java EE，所以踩的坑基本都是配置问题 项目的创建和导入项目 创建项目时，文件结构没有设置好，导致创建后，文件编译输出的文件夹错乱 导入的jar包，没有经过筛选，直接丢包，浪费一些资源空间 导入项目的时候，没有配置好 Modules 等，导致项目无法运行 编译版本问题最初是因为偷懒，直接用的集成软件 Jspstudy。Jspstudy只有Tomcat 6 和 7，而笔者用的是 JDK 1.8，所以Tomcat运行不起来，后面采取官网下的Tomcat 9 架构代码的不合理项目练习采用的是 三层架构，不过我犯了错误，将逻辑层的代码嵌入到了表示层。然后就被教育了。 单元测试不合理 单元测试用的是Junit4，测试的是DAO，而不是Service 单元测试只是简单的测试代码能否运行，没有进行举例和断言 Servlet 用PostMan测试，但没有形成一份测试文档 项目的发布 在对Tomcat进行配置的时候，没有设置好 url 访问的根目录，所以放进 Tomcat 的webapps目录下后，网站运行起来，各种的访问路径问题 对 Tomcat 进行多站点配置的时候，配置文件一直报错 参考 IDea发布JavaWeb项目 详解一 Servlet第一篇【介绍Servlet、HTTP协议、WEB目录结构、编写入门Servlet程序、Servlet生命周期】 Servlet第二篇【Servlet调用图、Servlet细节、ServletConfig、ServletContext】 Servlet第三篇【request和response简介、response的常见应用】 Servlet第四篇【request对象常用方法、应用】 Servlet第五篇【介绍会话技术、Cookie的API、详解、应用】 Servlet第六篇【Session介绍、API、生命周期、应用、与Cookie区别 Cookie 与 Session 的区别 理解 IntelliJ IDEA 的项目配置和Web部署 IntelliJ IDEA WEB项目的部署配置","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"JAVA EE 软件开发体系架构","slug":"javaee","date":"2018-08-19T06:48:03.000Z","updated":"2018-08-19T07:07:59.458Z","comments":true,"path":"javaee/","link":"","permalink":"https://www.huizhe.xyz/javaee/","excerpt":"","text":"两层架构 客户端（前台） 信息系统（后台） 传统的客户端服务器系统仅只简单地基于两层体系来构建,没有任何中间件业务逻辑层与表示出或数据层混在一起,成本较高 三层架构三层架构自上而下将系统分为表示层、逻辑层、持久层。区分层次的目的是为了“高内聚低耦合”。 表示层 Web 由处理用户交互的客户端组建及其容器所组成 业务逻辑层 Service 由解决业务问题的组建组成,处于数据访问层和表示层中间，起到了数据交换中承上启下的作用。业务逻辑层的设计对于一个支持可扩展的架构尤为关键，因为它扮演了两个不同的角色。 对于数据访问层而言，它是调用者 对于表示层而言，它是被调用者 数据层 DAO 有时候也称为持久层，由一个或多个数据库组成，并可包含存储过程。其功能主要是负责对数据库的访问。 三层架构特点在处理客户端的请求时，使客户端不用进行复杂的数据库处理；透明地为客户端执行许多工作并且能够帮助开发人员创建适用于企业的大型分布式应用程序 在表示层方面一般不会直接访问 JSP 文件，会使用Servlet 进行页面转发。因此在 Servlet 进行处理数据。 三层架构把不同层的业务职责分离得更加彻底，逻辑层不包含一丁点的视图层代码。若包含了其他层的代码就不能做到完全解耦，依旧会存在一定程度的耦合性 三层架构更好的实现了模块化编程，使用三层架构设计的系统可以更容易的扩展及更换。 三层架构优缺点优点： 开发人员可以只关注整个结构中的某一层 层次更换的时候可以很容易实现 降低层与层之间的依赖 有利于各层逻辑的复用 结构明确，极大降低维护成本和维护时间 缺点： 降低了系统的性能。访问数据需经过中间层完成 有时会导致级联修改。 MVC 模式在MVC模式中，应用程序被划分为 模型层(Model)、视图层(View)、控制层(Controller) 三部分。MVC模型就是把一个应用程序的开发按照业务逻辑、数据、视图进行分离分层并组织代码MVC 要求把应用的模型按一定的层次规则抽取出来，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 模型层负责封装应用的状态，并实现功能 视图层负责将内容呈现给用户 控制层富足控制视图层发送的请求以及程序的流程 Servlet + JSP + JavaBean （MVC）这种模式比较适合开发复杂的web应用在该模式下 Servlet 负责处理用户请求 JSP 负责数据显示 JavaBean 负责封装数据 三层架构与MVC模式的区别 两者相同的地方是 都有一个表现层 三层架构是没有 Controller 控制器概念的 MVC没有把业务逻辑访问看成两个层 三层架构中典型的 Model层 是以实体类构成的 而MVC，则是由业务逻辑与访问数据组成的 基于Java EE 架构下的MVC在MVC架构模式中，模型层 定义了 数据模型 和业务逻辑。为了将数据访问与业务逻辑分离，降低代码之间的耦合，提高业务精度模型层又具体划分为了 DAO 层 和 业务层。 DAO 层 (Data Access Object) 其主要职能是将访问数据库的代码封装起来，将这些代码不会再其他层出现或者暴露出来给其他层 业务层 是整个系统最核心也是最具有价值的一层，该层封装应用程序的业务逻辑，处理数据，关注客户需求，在业务处理过程中会访问原始数据或产生新数据 DAO 层提供的DAO类能很好地帮助业务层完成数据处理业务层本身侧重于对客户需求的理解和业务规则的适应总体来说，DAO层 不处理业务逻辑，只为业务层提供辅助，完成获取原始数据或持久层数据等操作 JSP jsp被用来产生Web的动态内容。这层把应用数据以网页的形式呈现给浏览器，然后数据按照在JSP中开发的预定的方式表示出来，这层也可以称之为布局层 Servlet JSP 建立在 Servlet 之上，Servlet 是J2EE的重要组成部分 Servlet 负责处理用户请求，Java Web 项目的所有配置都写在了 web.xml 配置文件上，当项目运行的时候，web.xml 会将http请求映射给对应的Servlet类 JavaBean 由一些具有私有属性的Java类组成，对外提供 get 和 set 方法 JavaBean 负责数据，负责处理视图层和业务逻辑之间的通信 Service 业务处理类，对数据进行一些预处理 DAO 数据访问层，JDBC 调用存储过程 从 DataBase 那里获取到数据，再封装到Model实体类中去 参考从懵逼到再入门——JavaEE完整体系架构","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"},{"name":"Architecture","slug":"Architecture","permalink":"https://www.huizhe.xyz/tags/Architecture/"}]},{"title":"利用163邮箱发送简单邮件","slug":"SendEmail","date":"2018-08-10T12:16:46.000Z","updated":"2018-08-10T12:27:06.805Z","comments":true,"path":"SendEmail/","link":"","permalink":"https://www.huizhe.xyz/SendEmail/","excerpt":"","text":"在学习使用 JAVA 发送邮件之前，我们先来了解一下邮件协议 邮件协议常用的电子邮件协议有 SMTP，POP3，IMAP4，它们都隶属于 TCP/IP协议 簇。默认状态下，分别通过TCP端口25，110，143 建立连接。 SMTP 协议 SMTP 的全称是 Simple Mail Transfer Protocol，即简单邮件传输协议，它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式 SMTP 协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 SMTP 服务器就是遵循SMTP协议的发送邮件服务器 SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机 增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰 实际上，SMTP 已经是E-mail传输的标准 SMTP 规范（RFC 821)规定，每一行都要以\\r\\n 来结尾 POP 协议 POP3(Post Office Protocol 3)即邮局协议的第3个版本,是因特网电子邮件的第一个离线协议标准 POP邮局协议负责从邮件服务器中检索电子邮件 它要求邮件服务器完成下面几种任务之一 从邮件服务器中检索邮件并从服务器中删除这个邮件 从邮件服务器中检索邮件但不删除它 不检索邮件，只是询问是否有新邮件到达 POP协议支持多用户互联网邮件扩展，后者允许用户在电子邮件上附带二进制文件，如文字处理文件和电子表格文件等，实际上这样就可以传输任何格式的文件了，包括图片和声音文件等 在用户阅读邮件时，POP命令所有的邮件信息立即下载到用户的计算机上，不在服务器上保留 IMAP 协议 互联网信息访问协议（IMAP）是一种优于POP的新协议 和POP一样，IMAP也能下载邮件、从服务器中删除邮件或询问是否有新邮件，但IMAP克服了POP的一些缺点 它可以决定客户机请求邮件服务器提交所收到邮件的方式，请求邮件服务器只下载所选中的邮件而不是全部邮件 客户机可先阅读邮件信息的标题和发送者的名字再决定是否下载这个邮件 通过用户的客户机电子邮件程序，IMAP可让用户在服务器上创建并管理邮件文件夹或邮箱、删除邮件、查询某封信的一部分或全部内容，完成所有这些工作时都不需要把邮件从服务器下载到用户的个人计算机上。 RFC882 文档说明RFC882文档规定了如何编写一封简单的邮件（纯文本邮件），一封简单的邮件包含邮件头和邮件体两个部分 邮件头from 用于指明发件人to 用于指明收件人subject 用于说明邮件主题cc 抄送，将邮件发送给收件人的同时抄送另一个收件人、收件人可以看到邮件抄送给了谁bcc 密送，将邮件发送给收件人的同时将邮件秘密发送另一个收件人，收件人无法看到邮件密送给了谁 MIME 协议 MIME, 全称为“Multipurpose Internet Mail Extensions”, 比较确切的中文名称为“多用途互联网邮件扩展” 它是当前广泛应用的一种电子邮件技术规范，基本内容定义于RFC 2045-2049（注意RFC1521和RFC1522是它的过时版本） MIME试图在不改变SMTP协议和RFC822（邮件格式标准）的基础上，使得邮件可以传送任意二进制文件 MIME协议是对RFC822文档的升级和补充 了解完了基本的协议之后，我们开始进入主题 Java发送邮件类JavaMail JavaMail API提供了一个独立于平台且与协议无关的框架来构建邮件和消息传递应用程序 JavaMail API作为可选包提供，用于 Java SE平台 ，也包含在 Java EE平台中。 JavaMail创建的邮件是基于MIME协议的。因此可以使用JavaMail创建出包含图片，包含附件的复杂邮件。 javaMail文档说明 Session Session 定义了一个基本的邮件会话，任何工作都是基于这个Session的 Session 对象需要一个 java.util.Properties 对象来得到一些信息，如邮件服务器，用户名，密码这样的信息 Session 的构造函数是私有的，可通过getDefaultInstance() 方法来取得一个单一的可以被共享的默认session Message 创建好Session 对象之后，就可以创建Message来发送了 Message 是抽象类，大部分应用是使用其子类 javax.mail.internet.MimeMessage 方法 setFrom() 设置发送者 setRecipient(type,address) 设置接收者 setSubject() 设置主题 setContent 设置内容 Message.RecipientType有几个预先定义好的类型 Message.RecipientType.TO 收件人 Message.RecipientType.CC 抄送 Message.RecipientType.BCC 暗送 Address 当你已经创建Session 以及 Message，并且已经为message 填充了内容，那么接下来要做的就是给你的邮件添加一个地址（Address） Address 也是一个抽象类，我们使用其子类 javax.mail.internet.InternetAddress Transport Transport 是一个抽象类 使用Session 的 getTransport() 方法获取一个实例 使用sendMessage(message, message.getAllRecipients()) 方法发送邮件 代码编写我们已经了解了要用的几个类了，现在我们开始写代码完成邮箱发送的功能。注意： 邮箱发送会用到本地的 25端口 ，请确保25端口处于开启状态 163邮箱需开启 SMTP 服务 编写 properties 配置1234username=你的用户名password=163的授权码personal=发送人姓名smtpPort=SSL连接时SMTP服务器的端口，QQ是465或587 读取 properties 配置12345678910111213private void configInit()&#123; properties = new Properties(); try(InputStream in = Files.newInputStream(Paths.get(\"mail.properties\")))&#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; username = properties.getProperty(\"username\"); password = properties.getProperty(\"password\"); personal = properties.getProperty(\"personal\"); smtpPort = properties.getProperty(\"smtpPort\");&#125; properties 文件是放在根目录下的 smtp 配置初始化1234567891011121314private void setSmtpInit()&#123; //设置邮件服务器主机名 properties.put(\"mail.host\",\"smtp.163.com\"); //发送邮箱协议名称 properties.put(\"mail.transport.protocol\",\"smtp\"); //是否认证 properties.put(\"mail.smpt.auth\", \"true\"); //SSL连接时,开启下列代码 properties.setProperty(\"mail.smtp.port\", smtpPort); properties.setProperty(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\"); properties.setProperty(\"mail.smtp.socketFactory.fallback\", \"false\"); properties.setProperty(\"mail.smtp.socketFactory.port\", smtpPort);&#125; 设置发送内容123456789101112131415161718192021private Message setMessage(String to, String title, String content)&#123; //创建邮件 Message message = new MimeMessage(session); try&#123; //邮件发送者 personal message.setFrom(new InternetAddress(username,personal,\"UTF-8\")); //邮件接收者 message.setRecipient(Message.RecipientType.TO,new InternetAddress(to,personal,\"UTF-8\")); //邮件主题 message.setSubject(title); //邮件内容 message.setContent(content,\"text/html;charset=UTF-8\"); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;finally &#123; return message; &#125;&#125; 发送邮件12345678910111213141516public void sendMailBySTMP(String to, String title, String content) throws Exception&#123; configInit(); setSmtpInit(); // 创建会话对象 session = Session.getDefaultInstance(properties); //打印 debug 信息 session.setDebug(true); //创建邮件 Message message = setMessage(to, title, content); //邮件发送 Transport transport = session.getTransport(); transport.connect(username,password); transport.sendMessage(message,message.getAllRecipients()); transport.close();&#125; 使用12345public static void main(String [] args) throws Exception&#123; SendEmail email = new SendEmail(); email.sendMailBySTMP(\"a22783276@gmail.com\",\"hello\",\"content\");&#125; 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.io.IOException;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Properties;public class SendEmail&#123; public static void main(String [] args) throws Exception&#123; SendEmail email = new SendEmail(); email.sendMailBySTMP(\"a22783276@gmail.com\",\"hello\",\"content\"); &#125; private String smtpPort; private String username; private String password; private String personal; private Properties properties; private Session session; /** * 获取配置文件 */ private void configInit() &#123; properties = new Properties(); try(InputStream in = Files.newInputStream(Paths.get(\"mail.properties\")))&#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; username = properties.getProperty(\"username\"); password = properties.getProperty(\"password\"); personal = properties.getProperty(\"personal\"); smtpPort = properties.getProperty(\"smtpPort\"); &#125; /** * smtp 配置初始化 */ private void setSmtpInit() &#123; //设置邮件服务器主机名 properties.put(\"mail.host\",\"smtp.163.com\"); //发送邮箱协议名称 properties.put(\"mail.transport.protocol\",\"smtp\"); //是否认证 properties.put(\"mail.smpt.auth\", \"true\"); //设置465 端口 properties.setProperty(\"mail.smtp.port\", smtpPort); properties.setProperty(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\"); properties.setProperty(\"mail.smtp.socketFactory.fallback\", \"false\"); properties.setProperty(\"mail.smtp.socketFactory.port\", smtpPort); &#125; /** * 发送邮件 * @param to 接收者邮箱 * @param title 标题 * @param content 正文 * @throws Exception */ public void sendMailBySTMP(String to, String title, String content) throws Exception &#123; configInit(); setSmtpInit(); // 创建会话对象 session = Session.getDefaultInstance(properties); //打印 debug 信息 session.setDebug(true); //创建邮件 Message message = setMessage(to, title, content); //邮件发送 Transport transport = session.getTransport(); transport.connect(username,password); transport.sendMessage(message,message.getAllRecipients()); transport.close(); &#125; /** * 设置邮件信息 * @param to 接收者邮件 * @param title 标题 * @param content 正文 * @return */ private Message setMessage(String to, String title, String content) &#123; //创建邮件 Message message = new MimeMessage(session); try&#123; //邮件发送者 personal message.setFrom(new InternetAddress(username,personal,\"UTF-8\")); //邮件接收者 message.setRecipient(Message.RecipientType.TO,new InternetAddress(to,personal,\"UTF-8\")); //邮件主题 message.setSubject(title); //邮件内容 message.setContent(content,\"text/html;charset=UTF-8\"); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;finally &#123; return message; &#125; &#125;&#125; 参考JAVAMAIL使用使用JavaMail创建邮件和发送邮件","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"并发学习笔记 (三)","slug":"Concurrency3","date":"2018-08-05T10:02:29.000Z","updated":"2018-08-05T10:22:39.421Z","comments":true,"path":"Concurrency3/","link":"","permalink":"https://www.huizhe.xyz/Concurrency3/","excerpt":"","text":"SimpleDateFormatSimpleDateFormat 类的 JavaDoc我们先来看看 SimpleDateFormat 类的 JavaDoc12345678910111213* Date formats are not synchronized.* It is recommended to create separate format instances for each thread.* If multiple threads access a format concurrently, it must be synchronized* externally.** @see &lt;a href=\"https://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html\"&gt;Java Tutorial&lt;/a&gt;* @see java.util.Calendar* @see java.util.TimeZone* @see DateFormat* @see DateFormatSymbols* @author Mark Davis, Chen-Lieh Huang, Alan Liu*/public class SimpleDateFormat extends DateFormat &#123; JavaDoc 中，我们将英文翻译一下： 建议为每个线程创建单独的日期／时间格式实例。 如果多个线程同时访问一个日期／时间格式，则必须同步 场景练习通过具体的场景，我们来深入学习和理解 SimpleDateFormat 类 我们假设有一个静态变量：1public static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); 若多个线程都执行以下操作1String dateStamp = dateFormat.format(new Date); 结果可能很混乱，因为 dateFormat 使用的内部数据结构可能会被并发的访问所破环。 场景代码实现我们可以运行一下源码看看结果 这里为了数据量大一点，可以更好的显示结果，所以我用了死循环，需要手动终止程序。 1234567891011121314151617181920212223242526272829303132import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateUtilsUnSynch &#123; private static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public static String formatDate(Date date) throws ParseException &#123; return sdf.format(date); &#125; public static Date parse(String strDate) throws ParseException &#123; return sdf.parse(strDate); &#125; public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName()+\": \" + DateUtilsUnSynch.parse(\"2018-08-02 09:45:23\")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;; while(true)&#123; new Thread(r).start(); &#125; &#125;&#125; 运行结果如下：123456789101112131415Exception in thread \"Thread-720\" java.lang.NumberFormatException: For input string: \"425018.E4250184E4\" at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2043) at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) at java.lang.Double.parseDouble(Double.java:538) at java.text.DigitList.getDouble(DigitList.java:169) at java.text.DecimalFormat.parse(DecimalFormat.java:2089) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at javabook.SimpleDateUnSynch.DateUtilsUnSynch.parse(DateUtilsUnSynch.java:16) at javabook.SimpleDateUnSynch.DateUtilsUnSynch.lambda$main$0(DateUtilsUnSynch.java:23) at java.lang.Thread.run(Thread.java:748)Thread-754: Thu Aug 02 09:45:23 CST 2018Thread-46: Thu Aug 02 09:45:23 CST 8Thread-753: Thu Aug 02 09:45:23 CST 2018 结果分析 我们可以看到 Thread-720 直接挂死了，没起来 Thread-46 虽然没挂死，但输出的时间是有错误的 为什么会出现线程不安全的问题呢？为什么上文会说 dateFormat 使用的内部数据结构可能会被并发的访问所破环呢？ JDK 源码因为 SimpleDateFormat 继承了 DateFormat，所以我们先来看看 DateFormat 的源码12345678910111213public abstract class DateFormat extends Format &#123; /** * The &#123;@link Calendar&#125; instance used for calculating the date-time fields * and the instant of time. This field is used for both formatting and * parsing. * * &lt;p&gt;Subclasses should initialize this field to a &#123;@link Calendar&#125; * appropriate for the &#123;@link Locale&#125; associated with this * &lt;code&gt;DateFormat&lt;/code&gt;. * @serial */ protected Calendar calendar; 一进入 DateFormat 类，我们就可以看到 DateFormat 中定义了一个protected属性的 Calendar 类的对象：calendar 在回头看看 SimpleDateFormat 的源码，我们主要关注两个方法： private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) 在 format 方法中，我们可以看到 calendar.setTime(date); 该语句修改了 calendar 由此我们可以发现为什么上文中运行结果会出现错误了。 我们假设有两个线程持有了同一个 SimpleDateFormat 的实例，并分别调用了 format 方法 线程 1 调用了 format 方法，改变了 calendar 线程 1 中断了 线程 2 调用了 format 方法，改变了 calendar 线程 2 中断了 线程 1 回来了 calendar 被 线程2 改变了，所以线程1 走上了线程2 设计的道路 如果多个线程同时争抢 calendar 对象，则会出现各种问题 而在 subFormat 方法中，则大量的使用到了 calendar 变量，由此我们可以看到将 calendar 设置为成员变量的好处：就是调用 subFormat 方法的时候，少了一个参数。不过恰恰是因为这个，而带来了很多问题。 小结综上，我们学习了 为什么 SimpleDateFormat 为什么是线程不安全的原因了。那么，我们该如何解决呢？ 解决方案 需要的时候创建新实例 即在需要用到 SimpleDateFormat 对象的时候新建一个实例。将 非线程安全 的类设置为 局部私有 就能避免多线程问题。不过，由此也加重了创建对象的负担。 使用同步：即 synchronized 关键字 1234567891011121314151617181920212223242526272829303132import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateUtilsUnSynch &#123; private static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public synchronized static String formatDate(Date date) throws ParseException &#123; return sdf.format(date); &#125; public synchronized static Date parse(String strDate) throws ParseException &#123; return sdf.parse(strDate); &#125; public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName()+\": \" + DateUtilsUnSynch.parse(\"2018-08-02 09:45:23\")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;; while(true)&#123; new Thread(r).start(); &#125; &#125;&#125; 不过采用这种方案，开销会很大。 使用线程局部变量 ThreadLocal 123456789101112131415161718192021import java.text.ParseException;import java.text.SimpleDateFormat;public class DateThreadLocalTest &#123; public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName()+\": \" + dateFormat.get().parse(\"2018-08-02 09:45:23\")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;; while(true)&#123; new Thread(r).start(); &#125; &#125;&#125; 在一个给定线程中首次调用get方法时，会调用initialValue 方法。之后，get方法会返回属于当前线程的那个实例 使用ThreadLocal，将共享变量变为独享，减少创建对象的开销。 对性能要求比较高情况下，一般推荐使用这种方法。 java.lang.ThreadLocal 1.2 T get() 得到这个线程的当前值，如果是首次调用get，会调用 initialize 来得到这个值 protected initialize() 应覆盖这个方法来提供一个初始值。默认情况下，这个方法返回null void set(T t) 为这个线程设置一个新值 void remove() 删除对应这个线程的值 static &lt;S&gt; ThreadLocal&lt;S &gt; withInitial(Supplier&lt;? extends S&gt; supplier) 8 创建一个线程局部变量，其初始值通过调用给定的supplier 生成 Random如果多个线程需要等待一个共享的随机数生成器，这会很低效。可使用ThreadLocal 辅助类为各个线程提供一个单独的生成器。 JAVA SE 7 提供了一个便利类12//bound 为数字int random = ThreadLocalRandom.current().nextInt(int bound); ThreadLocalRandom.current() 调用会返回特定与当前线程的Random 类实例。 参考JAVA核心技术（卷1）原书第10版SimpleDateFormat 如何安全的使用？","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"并发学习笔记 (二)","slug":"Concurrency2","date":"2018-08-05T07:37:29.000Z","updated":"2018-08-05T07:46:38.594Z","comments":true,"path":"Concurrency2/","link":"","permalink":"https://www.huizhe.xyz/Concurrency2/","excerpt":"","text":"java 内存模型首先我们来看一下java的内存模型 我们可以看到，当需要处理数据时，CPU会从Cache中取值。但是有一个问题出现，就是 Cache 中的数据是从主内存拷贝过来的。在多线程场景下，这个 Cache 拷贝的值有时候没能得到及时地更新，此时，CPU处理完的结果很有可能会失控。此问题就是缓存一致性问题，即Cache和主内存数据同步问题。 那我们该怎么解决这个问题呢？ 通过在总线加 LOCK 锁通过独占 CPU 方式 实现，即同一时间只有一个CPU在运行，效率较低 通过 缓存一致性 协议允许多核处理，并且让共享副本在线程之间具有可见性 并发编程的三大概念可见性可见性是指 线程之间的可见性。即一个线程修改的状态对另一个线程是可见的。也就是说，当一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 原子性原子是最小单位，具有不可分割性。原子性：即一个操作或多个操作，要么全部执行要么全部执行。 在java中，对基本数据类型的变量的 读取和赋值 操作是原子性操作。 非原子操作都会存在线程安全问题，此时我们需要用到同步技术(synchronized) 来让它变化一个原子操作。一个操作是原子操作，我们就称它具有原子性。 有序性有序性就是程序执行的顺序按照 代码的先后顺序 执行 指令重排序 一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中的各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果是一致的。 指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 在java内存模型中，允许编译器和处理器对指令进行重排序。 Volatile 域volatile 概念 volatile 关键字为实例域的同步访问提供了一种免锁机制。 如果声明一个域为 volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。 即保证了不同线程对这个变量进行读取时的可见性。 volatile 修饰的变量禁止 指令重排序 volatile 修饰的变量，JVM保证每次读变量都从内存中读，跳过了CPU Cache 这一步 volatile 可见性我们来看一段代码1234567//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125;//线程2stop = true; 上面这段代码虽然是存在比较小的概率会导致无法中断线程，但是一旦发生，就会造成死循环了虽然线程2将 stop 设置为了true，但是如果线程没将stop变量写入主存当中，线程1就会一直循环下去 但是用了 volatile 关键字之后 使用 volatile 关键字会强制将修改的值立即写入主存 当线程2进行修改时，会导致线程1的工作内存中缓存变量的 stop 的缓存行无效 线程1工作内存中缓存变量stop的缓存行被无效化，因此线程1再次读取变量stop的值时会去主存读取 为什么volatile是非原子性 volatile的非原子性：线程工作内容中的值从主内存中直接加载，一旦加载完成，就不会再产生对应的变化。 JVM保证的是从主内存中加载到线程工作内存中的值是最新的，但是无法保证原子性。 volatile解决的是变量读时的可见性问题，无法保证原子性。 我们来看一段代码1234567891011121314151617public class VolatileTest implements Runnable&#123; static volatile int i = 1; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\" : \"+i +\", \"+ (++i)); &#125; public static void main(String[] args) &#123; for (int j = 0;j &lt;100;j++) &#123; Thread t1 = new Thread(new VolatileTest(),Integer.toString(j)); t1.start(); &#125; &#125;&#125; 打印结果 通过仔细的查看，我们可以看到有两个线程获取到的 i 都是 95，但是执行 ++i 之后，一个是97，一个是96了。这是因为 +i 和 +(++i) 是两条指令假设当前 i = 1，线程1和线程2都执行了+i，然后线程1执行了+(++i),此时 i=2，然后线程2执行 +(++i)，此时 i=3，所以线程1 输出了（1，2），而线程2输出（1，3）由此我们可以得知，volatile 不能解决并发计算问题 volatile 使用场景通常来说，使用volatile必须具备以下2个条件： 1. 对变量的写操作不依赖于当前值 2. 该变量没有包含在具有其他变量的不变式中 状态标识 一次性安全发布 参考 JAVA核心技术（卷1）原书第10版 Java 并发——volatile Java 之 volatile 详解","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"并发学习笔记（一）","slug":"Concurrency","date":"2018-08-04T07:46:54.000Z","updated":"2018-08-05T07:35:49.138Z","comments":true,"path":"Concurrency/","link":"","permalink":"https://www.huizhe.xyz/Concurrency/","excerpt":"线程：每一个任务称为一个线程（thread）,它是线程控制的简称。 可以同时运行一个以上线程的程序称为多线程程序。 多进程和多线程的区别： 本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。 共享变量使线程之间的通信比进程之间的通信更有效，更容易。","text":"线程：每一个任务称为一个线程（thread）,它是线程控制的简称。 可以同时运行一个以上线程的程序称为多线程程序。 多进程和多线程的区别： 本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。 共享变量使线程之间的通信比进程之间的通信更有效，更容易。 在线程中执行任务 将任务代码移到实现了 Runnable 接口的类的 run 方法中。这个接口只有一个方法 123public interface Runnable &#123; public abstract void run();&#125; 由于 Runnable 是一个函数式接口，可以用 lambda 表达式建立一个实例： 1Runnable r = () -&gt; &#123; task code &#125;; 由 Runnable 创建一个Thread 对象： 1Thread t = new Thread(r); 启动线程： 1t.start 也可以通过构建一个Thread类的子类定义一个线程 1234567class MyThread extends Thread&#123; public void run() &#123; task code &#125;&#125; 注意：不要调用 Thread 类或 Runnable 对象的run方法。直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用 Thread.start 方法。。该方法将创建一个执行run方法的新线程。 java.lang.Thread Thread(Runnable target)构造一个新线程，用于调用给定目标的 run() 方法 void start()启动这个线程，将引发调用 run() 方法。这个方法将立即返回，并且新线程将并发运行 void run()调用关联 Runnable 的 run 方法 java.lang.Runnable void run()必须覆盖这个方法，并在这个方法中提供所要执行的任务指令 中断线程当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。没有可以强制线程终止的方法。但是，interrupt 方法可以用来请求终止线程当线程调用 interrupt 方法时，线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志每个线程都应该不时地检查这个标志，以判断线程是否被中断。 可调用静态的 Thread.currentThread 方法获得当前线程，然后调用isInterrupted 方法123while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do)&#123; do more work&#125; 不过，如果线程被阻塞，就无法检测中断状态，这时就会抛出 InterruptedException 异常当在一个被阻塞的线程（调用 sleep 或 wait ）上调用 interrupt 方法时，阻塞调用将会被 InterruptedException 异常中断 java.lang.Thread void interrupt()向线程发送中断请求。线程的中断状态将被设置为true。如果该线程目前被sleep 或 wait 调用阻塞，那么，InterruptedException 异常被抛出 static boolean interrupted()测试当前线程是否被中断。注意，这是一个 静态方法。这一调用会产生副作用——它将当前线程的中断状态重置为false boolean isInterrupted()测试线程是否被终止。这一调用不改变线程的中断状态 static Thread currentThread()返回代表当前执行线程的Thread 对象 线程状态线程可以有如下6种状态： New (新创建) Runnable (可运行) Blocked (被阻塞) Waiting (等待) Timed waiting (计时等待) Terminated (被终止) 新创建线程当用 new 操作符创建一个新线程时，如 new Thread(r)，该线程还没有开始运行。这意味着它的状态是new 可运行线程一旦调用 start 方法，线程处于runnable 状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度 给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行） 被阻塞线程和等待线程当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且小号最少的资源。知道线程调度器重新激活它。细节取决于它是怎样达到非活动状态的 当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用 Object.wait 方法或 Thread.join 方法，或者是等待 java.util.concurrent 库中的 Lock 或 Condition 时，就会出现这种情况 有几个方法有一个超时参数。调用它们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时的方法有 Thread.sleep 和 Object.wait 、 Object.join 、 Lock.tryLock 以及 Condition.await 的计时版 被终止的线程 因为 run 方法正常退出而自然死亡 因为一个没有捕获的异常终止了 run 方法而意外死亡 同步在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？根据各线程访问数据的的次序，可能会产生讹误的对象。这样的情况通常被称为竞争条件 我们来模拟一个有若干账户的银行。随机地生成在这些账户之间转移在钱款的交易。每一个账户有一个线程。每一笔交易中，会从线程所服务的账户中随机转移一定数目的钱款到另一个随机账户。 账户转移的方法编写12345678910public void transfer(int from, int to, double amount)&#123; if (accounts[from] &lt; amount) return; System.out.println(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\"%10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance());&#125; Runnable 类的代码12345678910111213141516Runnable r = () -&gt;&#123; try &#123; while (true)&#123; //bank.size 返回的是Bank类accounts数组的长度，这里设置为100，数组中的值均为1000 int toAccount = (int)(bank.size() * Math.random()); //MAX_AMOUNT 为 1000 double amount = MAX_AMOUNT * Math.random(); bank.transfer(fromAccount, toAccount, amount); ///DELAY 为 10 Thread.sleep((int)(DELAY * Math.random())); &#125; &#125;catch (InterruptedException e)&#123; &#125;&#125;; 当这个模拟程序运行时，我们不清楚某一时刻某一个账户余额剩多少钱，不过我们唯一能确定的是，所有账户的总金额应该保持不变。应为 NACCOUNTS INITIAL_BALANCE所以我们在每次交易的结尾，transfer 方法重新计算总值打印出来。ps：这个程序是个死循环，只能按 *Ctrl+C 终止程序 程序运行结果如下： 正如结果所示，出现了错误。银行的余额应该保持在10W，才是正确的结果。但是过了一段时间之间，这个结果变了。 附上完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//测试类public class UnsynchBankTest &#123; public static final int NACCOUNTS = 100; public static final double INITIAL_BALANCE = 1000; public static final double MAX_AMOUNT = 1000; public static final int DELAY = 10; public static void main(String[] args) &#123; BankUnSynch bank = new BankUnSynch(NACCOUNTS, INITIAL_BALANCE); for (int i=0;i&lt;NACCOUNTS;i++) &#123; int fromAccount = i; Runnable r = () -&gt; &#123; try &#123; while (true)&#123; int toAccount = (int)(bank.size() * Math.random()); double amount = MAX_AMOUNT * Math.random(); bank.transfer(fromAccount, toAccount, amount); Thread.sleep((int)(DELAY * Math.random())); &#125; &#125;catch (InterruptedException e)&#123; &#125; &#125;; Thread t = new Thread(r); t.start(); &#125; &#125;&#125;//银行类import java.util.*;public class BankUnSynch &#123; private final double[] accounts; public BankUnSynch(int n, double initialBalance) &#123; accounts = new double[n]; Arrays.fill(accounts, initialBalance); &#125; /** * 转账操作 * @param from * @param to * @param amount */ public void transfer(int from, int to, double amount) &#123; if (accounts[from] &lt; amount) return; //获取当前线程 System.out.println(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\"%10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance()); &#125; /** * 获取 accounts 数组的总金额 * @return */ public double getTotalBalance() &#123; double sum = 0; for (double a: accounts) sum += a; return sum; &#125; public int size() &#123; return accounts.length; &#125;&#125; 竞争条件详解上面的代码运行时，其实有几个线程更新银行账户余额。一段时间之后，就出现了错误。总额要么增加了，要是变少了。当线程试图同时更新同一个账户的时候，这个问题就出现了。假设两个线程同时执行指令1accounts[to] += amount; 这个时候会发生什么呢？由于这不是原子操作。该指令可能会被处理为： 将 accounts[to] 加载到寄存器 增加 amount 将结果写回 accounts[to] 现在我们假定第一个线程执行步骤1和2，然后，它被剥夺了运行权。第二个线程被唤醒并修改了 accounts 数组中的同一项，即第二个线程执行完了这三个步骤。然后，第一个线程被唤醒并完成其第三步这样，这一动作就擦去了第二个线程所作的更新，于是，总金额不在正确。 锁对象如何防止上面情况的发生呢？有两种机制防止代码块受并发访问的干扰。 锁和条件对象 synchronized 关键字 加锁使用 ReentrantLock 保护代码块。代码如下 1234567myLock.lock();// 一个ReentrantLock 对象 try&#123; critical section&#125;finally&#123; myLock.unlock();&#125; 这样我们就可以确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象 条件对象现在我们来回想一下业务，当账户中没有足够的余额时，我们是不是应该等待直到另一个线程向账户中注入资金？但是因为这一线程刚刚获得了对bankLock的排他性访问，因此导致了其他线程都被阻塞，这就是成了死锁。这时，我们就需要用到条件对象了。 一个锁对象可以有一个或多个相关的条件对象。可以用 newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。 例如：123456789101112class Bank &#123; private Lock bankLock; private Condition sufficientFunds; public Bank() &#123; .... bankLock = new ReentrantLock(); sufficientFunds = bankLock.newCondition(); &#125;&#125; 当 transfer 方法发现余额不足，调用1sufficientFunds.await(); 表示当前线程现在被阻塞了，并放弃了锁。我们希望这样可以使得另一个线程可以进行增加账户余额的操作。 注意： 等待获得锁的线程和调用 await 方法的线程存在本质上的不同。一旦一个线程调用 await 方法，它进入该条件的 等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一线程调用同一条件上的 signalAll 方法时为止。 signalAll 方法激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。此时，线程应该再次测试该条件。由于无法确保该条件被满足—— signalAll 方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。因此，对await 的调用应该采用以下的方式12while(!(ok to proceed)) condition.await(); 何时调用 signalAll 方法呢？建议在对象的状态有利于等待线程的方向改变时调用 signalAll。如：当完成转账时，就调用 signalAll 方法。1234567891011121314151617public void transfer(int from,int to, double amount) throws InterruptedException&#123; bankLock.lock(); try &#123; while (accounts[from] &lt; amount) sufficientFunds.await(); System.out.println(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\"%10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance()); sufficientFunds.signalAll(); &#125;finally &#123; bankLock.unlock(); &#125;&#125; 另一个方法是signal，此方法是随机解除选择等待集中某个线程的阻塞状态。这个方法存在危险，即随机选择的线程发现自己仍然不能运行，那它就会再次被阻塞，若无其他线程再次调用signal，那系统就死锁了。 附上修改后的 Bank 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Arrays;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Bank &#123; private final double[] accounts; private Lock bankLock; private Condition sufficientFunds; /** * 初始化 * @param n 数组长度 * @param initialBalance */ public Bank(int n ,double initialBalance) &#123; accounts = new double[n]; Arrays.fill(accounts, initialBalance); bankLock = new ReentrantLock(); sufficientFunds = bankLock.newCondition(); &#125; /** * 转账操作 * @param from * @param to * @param amount * @throws InterruptedException */ public void transfer(int from,int to, double amount) throws InterruptedException &#123; bankLock.lock(); try &#123; while (accounts[from] &lt; amount) sufficientFunds.await(); System.out.println(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\"%10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance()); sufficientFunds.signalAll(); &#125;finally &#123; bankLock.unlock(); &#125; &#125; /** * 获取 accounts 数组的总金额 * @return */ public double getTotalBalance() &#123; bankLock.lock(); try&#123; double sum = 0; for (double a: accounts) sum += a; return sum; &#125;finally &#123; bankLock.unlock(); &#125; &#125; public int size() &#123; return accounts.length; &#125;&#125; 总结一下锁和条件的关键之处 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码 锁可以管理试图进入被保护代码段的线程 锁可以拥有一个或多个相关的条件对象 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程 synchronized 关键字Lock 和 Condition 接口为程序设计人员提供了高度的锁定控制。然而大多数情况下，并不需要那样的控制，并且可以使用一种嵌入到Java语言内部的机制。从 1.0 版本开始，Java 中的每一个对象都有一个内部锁。如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。即，要调用该方法，线程必须获得内部的对象锁。也就是说：123456789101112131415public synchronized void method()&#123; do something&#125;//等价于public void method()&#123; this.intrinsicLock.lock(); try&#123; do something &#125; finally&#123; this.intrinsicLock.unlock(); &#125;&#125; 内部对象锁只有一个相关条件。wait 方法添加一个线程到等待集中，notifyAll/notify 方法接触等待线程的阻塞状态。即，调用wait或notifyAll等价于12intrinsicCondition.await(); intrinsicCondition.signalAll(); 内部锁和条件存在一些局限： 不能中断一个正在试图获得锁的线程 试图获得锁时不能设定超时 每个锁仅有单一的条件，可能是不够的 Lock 和 Condition 对象、同步方法的使用的建议： 最好既不使用Lock/Condition 也不使用 synchronized 关键字。在许多情况下可以使用 java.util.concurrent 包中的一种机制，它会为你处理所有的加锁 如果 synchronized 关键字适合你的程序，那么就尽量使用它。 如果特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition 使用 synchronized 关键字修改源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class BankSynch &#123; private final double[] accounts; /** * 初始化 * @param n 数组长度 * @param initialBalance */ public BankSynch(int n ,double initialBalance) &#123; accounts = new double[n]; Arrays.fill(accounts, initialBalance); &#125; /** * 转账操作 * @param from * @param to * @param amount * @throws InterruptedException */ public synchronized void transfer(int from,int to, double amount) throws InterruptedException &#123; System.out.println(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\"%10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance()); &#125; /** * 获取 accounts 数组的总金额 * @return */ public synchronized double getTotalBalance() &#123; double sum = 0; for (double a : accounts) sum += a; return sum; &#125; public int size() &#123; return accounts.length; &#125;&#125; 还有一种是客户端锁定，不过客户端锁定是非常脆弱的，通常不推荐使用，这里就不叙述了。 参考JAVA核心技术（卷1）原书第10版","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"聊聊 JAVA 异常","slug":"Throwable","date":"2018-07-29T10:35:21.000Z","updated":"2018-09-03T02:26:46.054Z","comments":true,"path":"Throwable/","link":"","permalink":"https://www.huizhe.xyz/Throwable/","excerpt":"","text":"异常对象都是派生于Throwable 类的一个实例。 异常层次结构简化示意图: 所有的异常都是由Throwable 继承而来，但在下一层立即分解为两个分支：Error 和 Exception Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误 Exception 层次Exception 层次分解为两个分支： RuntimeException 和 其他异常 RuntimeException 异常： 错误的类型转换 ClassCastException 数组访问越界 ArrayIndexOutOfBoundsException 访问null指针 NullPointerException 不是派生于 RuntimeException 异常包括： 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在 Java语言规范将派生于 Error 异常或 RuntimeException 类的所有异常称为非受查(unchecked) 异常。 所有其他的异常称为受查(checked)异常。 什么时候该抛出异常 throws ： 调用一个抛出受查异常的方法 运行时发现错误，利用 throw 语句抛出一个受查异常 程序出现错误，如 ArrayIndexOutOfBoundsException 这样的非受查异常 Java 虚拟机和运行时库出现的内部错误 子类方法中声明的受查异常并不能比超类方法中声明的异常更通用，即子类方法中可抛出更特定的异常，或者根本不抛出任何异常。特别声明：如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。 自定义异常： 定义一个派生于Exception的类，或者派生于Exception子类的类。 习惯上，定义的类应该包含两个构造器。一个默认的构造器，另一个是带有详细描述信息构造器。 12345678class FileFormatException extends IOException&#123; public FileFormatException()&#123;&#125; public FileFormatException(String message) &#123; super(message); &#125;&#125; API java.lang.Throwable Throwable() 构造一个新的Throwable 对象，这个对象没有详细的描述信息 Throwable(String message) 构造一个新的Throwable，这个对象带有特定的详细描述信息。习惯上，所有的派生的异常类都支持一个默认的构造器和一个带有详细信息的构造器。 String getMessage() 获得Throwable 对象的详细描述信息 异常处理小技巧一般异常处理最好的选择，就是将异常传递给调用者，让调用者自己去操心。 在catch 字句中可以抛出一个异常，这样做的目的是改变异常的类型。我们可以采用一种比较推荐的处理异常的方法，并且将原始异常设置为新异常的”原因”: 12345678910try&#123; access the database&#125;catch(SQLException e)&#123; Throwable se = new ServletException(\"database error\"); se.initCause(e); throw se;&#125; 当捕获到异常时，就可以使用下面这条语句重新得到原始异常：1Throwable e = se.getCause(); 使用这种包装技术，可让用户抛出子系统中的高级异常，而不会丢失原始异常的细节 如果在一个方法中发生了一个受查异常，而不允许抛出它，那包装技术就十分有用。我们可捕获这个受查异常，并将它包装成一个运行时异常。 finally 语句 不管是否有异常被捕获，finally 字句中的代码都被执行。 当finally字句包含return 语句时，将会出现一种意想不到的结果。 假设利用return 语句从try语句块中退出。在方法返回前，finally字句的内容将被执行。如果finally字句中也有一个return语句，这个返回值将会覆盖原始的返回值。例： 123456789 public static int f(int n)&#123; try&#123; return n*n; &#125;finally &#123; if (2 == n) return 0; &#125;&#125; 如果调用f(2) ，try语句返回结果为4，然而在方法返回前，要执行finally字句。finally字句使得方法返回0。这个返回值覆盖了原先的返回值4。所以调用 f(2) 返回的值为 0。 JAVA SE7 关闭资源的处理待资源的try 语句(try-with-resources) 的最简形式1234try(Resource res = ...)&#123; work with res&#125; try 块退出时，会自动调用res.close() 指定多个资源：12345try(Scanner in = new Scanner(new FileInputStream(\"/usr/shar/dict/words\"),\"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\"))&#123; while (in.hasNext()) out.println(in.next().toUpperCase());&#125; 不管这个块如何退出，in 和 out 都会关闭。 常规方式手动编程，就需要两个嵌套的try/finally 语句。 堆栈轨迹(stack trace)堆栈轨迹是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。 访问堆栈轨迹的文本描述信息12345Throwable t = new Throwable();StackTraceElement[] frames = t.getStackTrace();for (StackTraceElement frame : frames)&#123; analyze frame&#125; StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法。同时，还含有能够获得类名和方法名的方法。 静态的 Thread.getAllStackTrace 方法，它可以产生所有线程的堆栈轨迹。例12345Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();for (Thread t : map.keySet())&#123; StackTraceElement[] frames = map.get(t); analyze frames&#125; 打印一个递归阶乘的函数的堆栈情况123456789101112131415161718192021222324252627282930public class StackTraceTest &#123; /** * 计算n的阶乘 * @param n * @return */ public static int factorial(int n) &#123; System.out.println(\"factorial(\" + n + \"):\"); Throwable t = new Throwable(); StackTraceElement[] frames = t.getStackTrace(); for (StackTraceElement f: frames) System.out.println(f); int r; if (n&lt;=1) r =1; else r = n * factorial(n-1); System.out.println(\"return \" + r); return r; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.print(\"Enter n : \"); int n = in.nextInt(); factorial(n); &#125;&#125; 计算factorial(3),打印一下内容123456789101112131415factorial(3):javabook.StackTraceTest.factorial(StackTraceTest.java:15)javabook.StackTraceTest.main(StackTraceTest.java:32)factorial(2):javabook.StackTraceTest.factorial(StackTraceTest.java:15)javabook.StackTraceTest.factorial(StackTraceTest.java:23)javabook.StackTraceTest.main(StackTraceTest.java:32)factorial(1):javabook.StackTraceTest.factorial(StackTraceTest.java:15)javabook.StackTraceTest.factorial(StackTraceTest.java:23)javabook.StackTraceTest.factorial(StackTraceTest.java:23)javabook.StackTraceTest.main(StackTraceTest.java:32)return 1return 2return 6 使用异常小技巧异常处理不能代替简单的测试与执行简单的测试相比，捕获异常所花费的时间大大超过前者。因此使用异常的基本规则是，旨在异常情况下使用异常机制。 不要过分地细化异常将整个任务包装在一个try块中，这样，当任何一个操作出现问题时，整个任务都可以取消。 利用异常层次结构 不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。 不要只捕获Throwable 异常，否则，会使程序代码更难读、更难维护 考虑受查异常和非受查异常的区别。 将一种异常转换成另一种更加适合的异常时不要犹豫。 不要压制异常在java中，往往强化地倾向关闭异常。 在检测错误时，“苛刻”要比放任更好例如，当栈空时，Stack.pop 是要返回一个null，还是抛出一个异常？我们认为：在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。 不要羞于传递异常让高层次的方法通知用户发生了错误，或者放弃不成功的命令更加适宜。 5 和 6 可以归纳为“早抛出，晚捕获”。参考JAVA核心技术（卷1）原书第10版","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"浅谈反射","slug":"reflection","date":"2018-07-27T08:29:41.000Z","updated":"2018-07-27T09:12:23.970Z","comments":true,"path":"reflection/","link":"","permalink":"https://www.huizhe.xyz/reflection/","excerpt":"反射：能够分析类能力的程序称为反射。反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。 反射机制：当程序无法获知对象类型时，在运行期间动态获取类的所有属性和方法。","text":"反射：能够分析类能力的程序称为反射。反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。 反射机制：当程序无法获知对象类型时，在运行期间动态获取类的所有属性和方法。 反射机制作用 在运行时分析类的能力 在运行时查看对象 实现通用的数组操作代码 反射机制的实现采用Class类和java.lang.reflect 类库一起实现 &lt;反射&gt;机制 Class 类： 代表一个目标类。 Field 类： 代表目标类的成员变量。 Method 类： 代表目标类的方法。 Constructor 类： 代表目标类的构造方法。 Array 类： 提供了动态创建数组，以及访问数组的元素的静态方法。 Class 类​ 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型表示。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 ​ 然而，可以通过专门的Java类访问这些信息。保存这些信息的类被成为Class，这个名字很容易让人混淆。Object 类中的getClass() 方法将返回一个Class类型的实例。 获取Class对象的三种方法 如果类在一个包里，包的名字也作为做类名的一部分。 123Random generator = new Random();Class cl = generator.getClass();System.out.println(cl.getName());//java.util.Random 如果类名保存字符串中，并可在运行时该变，即可使用这种方法。forName() 方法会爆ClassNotFoundException 异常，所以需要进行异常处理。 Class.forName() 内部通过反射API根据目标类名将类手动加载到内存中，称为类加载器加载方法。加载过程中会把目标类的static方法，变量，代码块加载到JVM，注意此时尚未创建对象实例 12String className = \"java.util.Random\";Class cl = class.forName(className); 如果T是任意的Java类型（或void 关键字），T.class 将代表匹配的类对象 1Class cl = Random.class; 获取构造器–Constructor 类 Constructor[] getConstructors()：获得所有public构造器； Constructor[] getDeclaredConstructors()：获得所有访问权限的构造器 Constructor getConstructor(Class[] params)：根据指定参数获得对应构造器； Constructor getDeclaredConstructor(Class[] params)：根据指定参数获得对应构造器； 获得方法–Method 类 Method[] getMethods()：获得所有public方法； Method[] getDeclaredMethods()：获得所有访问权限的方法； Method getMethod(String name, Class[] params)：根据方法签名获取类自身对应public方法，或者从基类继承和接口实现的对应public方法； Method getDeclaredMethod(String name, Class[] params)：根据方法签名获得对应的类自身声明方法，访问权限不限； 获得变量–Field 类 Field[] getFields()：获得类中所有public变量 Field[] getDeclaredFields()：获得类中所有访问权限变量 Field getField(String name)：根据变量名得到对应的public变量 Field getDeclaredField(String name)：根据变量名获得对应的变量，访问权限不限； 实战我们来个例子加深一下印象。 打印一个类的所有构造函数1234567891011121314151617181920public static void printConstructors(Class cl) &#123; //返回包含Constructor 对象的数组，其中包含了Class对象的所有构造器 Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c: constructors) &#123; //String getName() //返回一个用于描述构造器、方法或域名的字符串 String name = c.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+ \" \"); System.out.print(name+\"(\"); //Class[] getParameterTypes() (在Constructor 和 Method 类中) //返回一个用于描述参数类型的Class对象数组 printParameterType(c.getParameterTypes()); System.out.println(\");\"); &#125; &#125; 打印一个类的所有方法123456789101112131415161718192021public static void printMethods(Class cl) &#123; //返回包含Method 对象的数组，返回这个类或接口的全部方法，但不包括由超类继承了的方法 Method[] methods = cl.getDeclaredMethods(); for (Method m:methods) &#123; //Class getReturnType() (在 Method 类中) //返回一个用于描述返回类型的Class对象 Class retType = m.getReturnType(); String name = m.getName(); System.out.print(\" \"); //打印修饰符、返回类型和方法名称 String modifiers =Modifier.toString(m.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+\" \"); System.out.print(retType.getName()+\" \"+ name + \"(\"); printParameterType(m.getParameterTypes()); System.out.println(\");\"); &#125; &#125; 打印一个类的所有字段12345678910111213141516public static void printFields(Class cl) &#123; //Field[] getDeclaredFields() //返回包含Field 对象的数组，这些对象记录了这个类的全部域 Field[] fields = cl.getDeclaredFields(); for (Field f : fields)&#123; Class type = f.getType(); String name = f.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+\" \"); System.out.println(type.getName()+\" \"+ name+ \";\"); &#125; &#125; 打印方法的参数类型12345678public static void printParameterType(Class[] paramTypes) &#123; for (int j = 0;j&lt;paramTypes.length;j++) &#123; if (j&gt;0) System.out.print(\", \"); System.out.print(paramTypes[j].getName()); &#125; &#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; String name; if (args.length&gt;0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println(\"Enter class name(e.g java.util.Date): \"); name = in.next(); &#125; try &#123; //print class name and superclass name (if != object) //调用Class 的静态方法 forName 获得类名对应的Class 对象 Class cl = Class.forName(name); //获取父类所对应的Class 对象 Class supercl = cl.getSuperclass(); //返回对应modifiers 中位设置的修饰符的字符串表示 String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length()&gt;0) System.out.print(modifiers+\" \"); System.out.print(\"class \"+ name); //判断是否有继承父类 if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(\" extends \"+ supercl.getName()); System.out.print(\"\\n&#123;\\n\"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(\"&#125;\"); &#125;catch (ClassNotFoundException ex) &#123; ex.printStackTrace(); &#125; System.exit(0); &#125; 参考 JAVA核心技术（卷1）原书第10版 反射笔记","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://www.huizhe.xyz/tags/JAVA/"}]},{"title":"机器学习之识别验证码","slug":"Tesseract","date":"2018-03-19T14:55:57.000Z","updated":"2018-08-05T07:35:59.777Z","comments":true,"path":"Tesseract/","link":"","permalink":"https://www.huizhe.xyz/Tesseract/","excerpt":"","text":"下载 tesseract_ocr使用composer下载，tesseract_ocr1$ composer require thiagoalessio/tesseract_ocr ocr 测试123456require_once './vendor/autoload.php';use thiagoalessio\\TesseractOCR\\TesseractOCR;echo (new TesseractOCR('./1.jpg')) -&gt;lang('eng') -&gt;run(); 训练样本数据安装 Tesseract笔者这里是直接自动安装，没选择编译安装 1$ sudo apt install tesseract-ocr 下载图片12345678function getPicture($uri)&#123; for($i=0;$i&lt;100;$i++) &#123; $img = file_get_contents($uri); $filename = './test/'.$i.'.gif'; file_put_contents($filename,$img); &#125;&#125; 下载之后有点小问题，因为笔者电脑少了一个gif库，后面处理的时候总是有点问题。所以我用软件将 gif 转成了 png 格式. 安装 jTessBoxEditor 下载地址 笔者下载的是 jTessBoxEditor-2.0-Beta.zip 解压 1$ unzip jTessBoxEditor-2.0-Beta.zip 运行 1$ java -Xms128m -Xmx1024m -jar jTessBoxEditor.jar 图片转换成 tiff 格式因为jTessBoxEditor只能处理.tiff后缀的文件，因此我们需要将验证码图片转化为.tiff后缀，这里我们使用ImageMagick的convert工具进行转化，首先安装ImageMagick： 1$ sudo apt-get install imagemagick shell 脚本批量转换当前目录下的图片 创建 tran.sh 文件 1$ vim tran.sh tran.sh 文件内容 123456#~/bin/shfor file in `ls *.jpg` do name=$&#123;file%.*&#125; convert $file \"../tiff/\"$name\".tiff\" done 图片转换 1$ ./tran.sh 将 .tiff 文件合并成 .tif 文件打开 jTessBoxEditor ，点击界面上的Tools/Merge TIFF，将之前生成的 .tiff 文件合并成一个 .tif文件 官方定义 tif 文件的命名格式为：[lang].[fontname].exp[num].tif 生成 .box 文件1$ tesseract eng.test.exp0.tif eng.test.exp0 -l eng -psm 7 batch.nochop makebox 使用jTessBoxEditor校正字符打开刚才生成的eng.test.exp0.tif 文件，在左侧的Char列输入正确的值，调整x，y，w，h的值。可选择工具栏上的merge 和 split 对结果进行合并和拆分。点击下方中间的翻页查看下一张验证码。 自制语言库定义字体特征文件1$ echo test 0 0 0 0 0 &gt; font_properties 语法： fontname italic bold fixed serif fraktur fontname为字体名称，italic为斜体，bold为黑体字，fixed为默认字体，serif为衬线字体，fraktur德文黑字体，1和0代表有和无，精细区分时可使用。 生成字符特征文件1$ tesseract eng.test.exp0.tif eng.test.exp0 -l eng -psm 7 nobatch box.train 产生字符集1unicharset_extractor eng.test.exp0.box 生成shapetable1$ shapeclustering -F font_properties -U unicharset -O eng.test.exp0 eng.test.exp0.tr 生成聚集字符特征文件1$ mftraining -F font_properties -U unicharset -O eng.test.exp0 eng.test.exp0.tr 生成字符形状正常变化特征文件normproto12 cntraining eng.test.exp0.tr$ combine_tessdata test. 给inttemp,normproto,pffmtable,shapetable,unicharset 添加前缀 “test.”。生成语言库123456789101112131415161718192021$ combine_tessdata test.Combining tessdata filesTessdataManager combined tesseract data files.Offset for type 0 (test.config ) is -1Offset for type 1 (test.unicharset ) is 140Offset for type 2 (test.unicharambigs ) is -1Offset for type 3 (test.inttemp ) is 891Offset for type 4 (test.pffmtable ) is 137813Offset for type 5 (test.normproto ) is 137935Offset for type 6 (test.punc-dawg ) is -1Offset for type 7 (test.word-dawg ) is -1Offset for type 8 (test.number-dawg ) is -1Offset for type 9 (test.freq-dawg ) is -1Offset for type 10 (test.fixed-length-dawgs ) is -1Offset for type 11 (test.cube-unicharset ) is -1Offset for type 12 (test.cube-word-dawg ) is -1Offset for type 13 (test.shapetable ) is 139557Offset for type 14 (test.bigram-dawg ) is -1Offset for type 15 (test.unambig-dawg ) is -1Offset for type 16 (test.params-model ) is -1Output test.traineddata created successfully. 语言库存到tesseract中1$ sudo cp test.traineddata /usr/share/tesseract-ocr/tessdata/ 对比12345678910111213for ($i=0; $i &lt; 100; $i++) &#123; echo $i.\":\".(new TesseractOCR('./test/'.$i.'.jpg')) -&gt;lang('test') -&gt;run(); echo '\\r';&#125;for ($i=0; $i &lt; 100; $i++) &#123; echo $i.\":\".(new TesseractOCR('./test/'.$i.'.jpg')) -&gt;lang('eng') -&gt;run(); echo '\\r';&#125; 笔者用100张照片去对比，结果如下 因为eng是还有匹配字母，所有速度和正确率方面有所影响。test我主要是校正数字，所以速度上相对有优势，加上训练数据不大，正确率不是很高。 语言库 eng test 识别率 52% 69% Tesseract 识别的图片如果太脏，需要清洗一下，否则极影响识别率。","categories":[{"name":"php","slug":"php","permalink":"https://www.huizhe.xyz/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.huizhe.xyz/tags/php/"}]},{"title":"软考爬虫","slug":"Software","date":"2018-03-12T10:12:58.000Z","updated":"2018-08-05T07:35:53.441Z","comments":true,"path":"Software/","link":"","permalink":"https://www.huizhe.xyz/Software/","excerpt":"最近和同学在一起准备报考 计算机技术与软件专业技术资格（水平）考试，不过因为报名时间还没出，所以一直得关注网站是否已经可以报考。 刚好又在弄php的爬虫，所以就顺手做一个爬虫，再搭配一下Twilio做一个预警通知，就不用关注网站了，这样就轻松了很多。","text":"最近和同学在一起准备报考 计算机技术与软件专业技术资格（水平）考试，不过因为报名时间还没出，所以一直得关注网站是否已经可以报考。 刚好又在弄php的爬虫，所以就顺手做一个爬虫，再搭配一下Twilio做一个预警通知，就不用关注网站了，这样就轻松了很多。 注意：这里爬虫访问的是 广东人事考试网 使用工具：QueryList Twilio 先放一张成品图. 这里还没出2018的，所以用2017的测试 TwilioTwilio是一个做成开放插件的电话跟踪服务（call-tracking service）。美国当地时间2016年6月23日，云通讯公司Twilio在纽约证券交易所上市（来自于百度百科）。Twilio官网从国内访问的时候，可能会因为一些你懂的原因而导致无法访问，这时你就得学习一下怎么科学上网了。 QueryListQueryList是一个基于phpQuery的PHP通用列表采集类,得益于phpQuery，让使用QueryList几乎没有任何学习成本，只要会CSS3选择器就可以轻松使用QueryList了，它让PHP做采集像jQuery选择元素一样简单。 Twilio注册注册方法请移步 崔庆才 大神的博客，这里就不重复了。 安装因为是PHP版本的，所以用composer进行安装 Twilio PHP &gt;= 5.3 1composer require twilio/sdk QueryList PHP &gt;= 7.0 1composer require jaeger/querylist Twilio 代码1234567891011121314151617require_once &apos;./vendor/autoload.php&apos;;use Twilio\\Rest\\Client;function SendSMS($body)&#123; $account_sid = &quot;your account sid&quot;; $auth_token = &quot;your token&quot;; $client = new Client($account_sid, $auth_token); $messages = $client-&gt;messages-&gt;create( &quot;+接收者的号码&quot;, array( &apos;from&apos; =&gt; &apos;+twilio给你的号码&apos;, &apos;body&apos; =&gt; $body ) );&#125; QueryList 代码12345678910111213141516171819202122232425262728293031323334353637383940require_once &apos;./vendor/autoload.php&apos;;use QL\\QueryList;function getHtmlData($uri, $rules, $range)&#123; $html = QueryList::get($uri)-&gt;getHtml(); $data = QueryList::html($html)-&gt;rules($rules)-&gt;range($range) -&gt;query()-&gt;getData(); return $data-&gt;all();&#125;function send($uri)&#123; $rules = array( &apos;content&apos; =&gt; array(&apos;p&apos;,&apos;text&apos;), &apos;link&apos; =&gt; array(&apos;a&apos;,&apos;href&apos;) ); $range = &apos;#fontzoom&apos;; $dataArray = getHtmlData($uri, $rules, $range); $time = explode(&apos;：&apos;,explode(&apos;。&apos;,$dataArray[0][&apos;content&apos;])[0])[2]; $body = $time.&apos;。报名入口：&apos;.$dataArray[0][&apos;link&apos;]; SendSMS($body);&#125;$uri = &quot;http://www.gdrsks.gov.cn/HREducation/ExamList.aspx?ecid=2&amp;nodeid=1&amp;ekid=19&quot;;$rules = array( &apos;date&apos; =&gt; array(&apos;.date&apos;,&apos;text&apos;), &apos;content&apos; =&gt; array(&apos;.tit&apos;,&apos;text&apos;), &apos;link&apos; =&gt; array(&apos;.tit&apos;,&apos;href&apos;));$range = &apos;#mainContent&gt;div.wBd&gt;ul&gt;li&apos;;$data = getHtmlData($uri, $rules, $range);foreach ($data as $value) &#123; $array = explode(&apos;-&apos;, $value[&apos;date&apos;]); if (count($array) == 1) continue; if ($array[0] == &apos;2018&apos;) &#123; $uri = &apos;http://www.gdrsks.gov.cn&apos;.$value[&apos;link&apos;]; $uri = explode(&apos;&amp;&apos;,$uri)[0]; send($uri); break; &#125;&#125; 定时任务123crontab -e30 7 * * * /usr/bin/php your_file_pathsystemctl restart cron","categories":[{"name":"php","slug":"php","permalink":"https://www.huizhe.xyz/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.huizhe.xyz/tags/php/"},{"name":"crawler","slug":"crawler","permalink":"https://www.huizhe.xyz/tags/crawler/"}]},{"title":"Mysql和MariaDB 笔记","slug":"Mysql","date":"2018-02-27T08:29:41.000Z","updated":"2018-08-10T12:18:36.542Z","comments":true,"path":"Mysql/","link":"","permalink":"https://www.huizhe.xyz/Mysql/","excerpt":"","text":"含有空用户名加上localhost的组合，即任何用户名都可从localhost登陆 设置初始密码 mysqladmin -u root -p flush-privileges password “new_pwd”; mysqladmin 必须软链接到PATH中 Linux中：/usr/local/mysql/bin/mysqladmin 查看用户 mysql -u root -p -e “SELECT User,Host FROM mysql.user;”; 删除组合 mysql -u root -p -e “drop USER ‘root’@’%’;” 设置密码 mysql -u root -p -e “set password for ‘root’@’127.0.0.1’ password(‘new_pwd’);” 创建用户 mysql -u root -p -e “grant usage on . to ‘username’@’localhost’ identified by ‘password’;” 授权 mysql -u root -p -e “grant selecr/all on . to ‘username’@’localhost’;” 看表结构 describe tablename;show create tablename; \\G表示数据以行显示 创建数据库时指定字符集 create database databasenamecharacter set utf8 创建数据库时指定默认校对方式 rollate utf8_general_ci; 备份 \\表示告诉shell下一行还有 path表示路径 mysqldump –user=’username’ -p \\databasename [tablename] &gt; path 恢复备份 mysql –user=’username’ -p \\databasename [tablename] &lt; path 复制表结构 create table tablename like another_tablename; 复制表数据 insert into tablename select * from another_tablename; 修改表 alter table tablename changes 增加列 alter table tablename add column 列名 类型 索引 [after 列]; 删除列 alter table tablename drop column 列名; 修改列名 alter table tablename change column old_column new_column type; default b ‘默认值’ 表示设置默认值 修改/删除默认值 alter table tablenamealter columnname set/drop default []; 查看表的auto_increment值 select auto_increment from information_schema.tables where table_name = ‘tablename’; 修改auto_increment值 alter table tablename auto_increment = X; 修改/移动表 rename table tablename to tablename; 更改数据排列 alter table tablenameorder by ..; 在select 之前 加上explain 可查mysql根据什么 [索引] 查找数据 增加索引 alter table tablenameadd index indexname (column_name,[column_name]); 模糊搜索列名 show columns from tablename like ‘%xx%’; 插入数据(忽略错误) insert ignore into tablename select … from tablename; 显示错误 show warnings; 替换数据(replace) replace into tablename(column..) values(..) replace 替换的时候，如果有unique索引，是先删除原有的列，在插入新列，若无指定值，会插入默认值，若无索引，则是新插入列 数据插入的优先级(写在 insert 和 into 之间)insert 优先于 select 降低insert的优先级 (low_priority) 延迟插入 (delayed) MySQL5.5.6后不提倡用了 提升insert的优先级 (high_priority) 插入时处理重复数据1234insert into tablename select .. from tablename ...on duplicate key update ... 查询 1234select */column from tablename where column [in / is null / = / like &apos;%/_x&apos; ]order by column asc/ desclimit start,end; MySQL 先按where字句获取所有数据，并在幕后将结果存放于临时表，在按order by 排序，最后根据limit获取特定序列的数据 正则匹配123select * from tablename where column regexp [binary] &apos;...&apos;;binary 表示区分大小写 更新语句 ,update单表时可用order by 和 limit1234update tablename set column = .. where conditionorder by columnlimit row_count; 删除语句 ,delete单表时可用order by 和 limit1234delete from tablename where conditionorder by columnlimit row_count; 连删 (using 声明连接方式) using join方式1234567891011delete from table [, table]using table [,...][where condition];example：delete from humans, prize_winnersusing humans left join prize_winnerson humans.human_id = prize_winners.human_idwhere name_first = &apos;Elena&apos;and name_last = &apos;Bokova&apos;and email_address like &apos;%yahoo.com&apos;; 连表时两表有同列名 join using方式1234select * from tablejoin table using(column)where condition; 性能比较 使用benchmark()函数 内置函数拼接字符串 concat(column,what,column) 拼接字符串 concat_ws(what,column,column…) 判断NULL ifnull(column, default) 转换小写 lower() | lcase() 转换大写 upper() | ucase() 避免识别出错 quote() 单引号包围后输出，转移字符前加 \\ 去开头空格 ltrim() 去尾部空格 rtrim() trim() 不止可以去除两段空格，还可以去除别的字符如：” trim(both ‘字符’ from column) trim() 默认是both，去除一端可指定leading或者trailing 左端填充 lpad(str,len,padstr) 右端填充 rpad(str,len,padstr) 填充空格 space(N) MySQL 是从1开始的，而不是0 左截取 left(str,len) 右截取 left(str,len) 从右往左数 截取字符 substring(str,pos,len) 或者 mid(str,pos,len) 截取元素 substring_index(str,delim,count) locate(substr,column) 查找字串位置，返回字串出现的首位置 查找字串 position(substr in coliumn) 判断 if(what, yes, no) 获取字符长度 char_length(str) | character_length(str) 获取位数 bit_length(str) 比较函数 strcmp(expr1,expr2) 一致返回0 FULLTEXT索引模糊搜索 match(column) against(str) 替换函数 insert(column,pos,len,newstr) 第三个参数表示多少个字符被替换 类型转换 cast(column AS type) | convert(column,type) | convert(column using utf8) 压缩字符串，安装MySQL需带上压缩库(zlib) compress(str) 解压缩 uncompress(column) 时间函数当前日期和时间 now() | current_timestamp() | localtimestamp() | localtime() 暂停秒数 sleep(N) 获取自身被执行的时间点 systdate() 主要用于非常复杂的sql语句，或者存储过程和触发器之中 获取当前日期 curdate() 获取当前时间 curtime() 获取当前时间戳 unix_timestamp() 抽取日期 date(column) 抽取时间 time(column) 抽取年 year(column) 抽取月 month(column) 抽取日 day(column) 抽取小时 hour(column) 抽取分 minute(column) 抽取秒 second(column) 获取指定日期的月份 monthame() 获取指定日期的星期 dayame() 抽取函数 extract(unit FROM date) lntervar 返回格式 day dd day_hour ‘dd hh’ day_microsecond ‘dd.nn’ day_minute ‘dd hh:mm’ day_second ‘dd hh:mm:ss’ hour hh hour_microsecond ‘hh.nn’ hour_minute ‘hh:mm’ hour_second ‘hh:mm:ss’ microsecond nn minute mm minute_microsecond ‘mm.nn’ minute_second ‘mm:ss’ month mm quarter qq second ss second_microsecond ‘ss.nn’ week ww year yy year_month ‘yy-mm’ 格式化日期 date_format(date,format) 格式化时间 time_format(time,format) 代码 描述 结果 %a 简写的周几 (Sun…Sat) %b 简写的月份名字 (Jan…Dec) %c 月份(数字形式) (1…12) %d 一个月中的哪一天(数字形式) (00…31) %D 一个月中的哪一天(带有英文后缀) (1st,2nd,3rd…) %e 一个月中的哪一天(数字形式) (0…31) %f 毫秒(数字形式) (000000…999999) %h 小时 (01…12) %H 小时 (00…23) %i 分钟 (00…59) %I 小时 (01…12) %j 一年中的哪一天 (001…366) %k 小时 (0…23) %l 小时 (1…12) %m 月份 (01….12) %M 月份名字 (January….December) %p AM或者PM AM or PM %r 时间，12小时制 (hh:mm:ss[A P]M) %s 秒 (00…59) %S 秒 (00…59) %T 时间，24小时制 (hh:mm:ss) %u 一年中的第几周(以周一为一周的第一天) (0…52) %U 一年中的第几周(以周日为一周的第一天) (0…52) %v 一年中的第几周(以周一为一周的第一天，与%x一起使用) (1…53) %V 一年中的第几周(以周日为一周的第一天，与%X一起使用) (1…53) %w 一周中的哪一天 (0=Sunday…6=Saturday) %W 周几 (Sunday….Saturday) %x 某一周所属的年份(以周一为一周的第一天,4位数字形式，与%v一起使用) (yyyy) %X 某一周所属的年份(以周日为一周的第一天,4位数字形式，与%V一起使用) (yyyy) %y 年份(两位数字形式) (yy) %Y 年份(四位数字形式) (yyyy) %% 字面的%% ‘%’ 获取标准的日期格式 get_format({DATE|TIME|DATETIME}, {‘EUR’|’USA’|’JIS’|’ISO’|’INTERNAL’}) EUR 代表欧洲 USA 代表美国 JIS 代表日本工业标准 ISO 代表ISO 9075标准 INTERNAL 代表没有标点符号的时间格式 时区时间转换 convert_tz(datetime,from_tz,to_tz) 日期增加 date_add(date,interval expr unit) 日期缩减 date_sub(date,interval expr unit) 时间换算秒 time_to_sec(time) 秒换算时间 sec_to_time(seconds) 日期加减函数 period_add(P,N) 参数为字符串 日期比较 datediff(expr1,expr2) 日期比较 timediff(expr1,expr2) 聚合函数计算总数 count(expr1) 按组分 group by 求组分的同时求总数，可在group by 中加入 with rollup 求和 sum(expr) 求平均 avg([DISTINCT] expr) 求最大 max(expr) 求最小 min(expr) 组拼接 group_concat(expr) 四舍五入 round(X,D) 下舍入 floor(X) 上舍入 ceiling(X) 去掉小数 truncate(X,D) 绝对值 abs(X) 判断正负 sign(X) 设置用户自定义变量 set @name = expr; 数据库管理查看用户权限1show grants for &apos;username&apos;; 结果中的 . 是指授权使用所有数据库和所有表, ‘username’@’%’中主机是通配符 % ，无论何时都应该指定主机。 删除用户账号 drop user ‘username’@’..’, 删除前先查看mysql数据库的user表1select User,Host from mysql.user where User like &apos;%username%&apos;; 授权 grant privilege [(column…)] on database.table to ‘username’@’..’ 权限 描述 all [privileges] 授予所有基本的权限，但不包括grant option alter 允许使用alter table 语句，但得现有create和insert权限，如果想重命名一个表。还得现有drop权限，这里有一个安全隐患：用户可以通过对表改名来获得访问权 alter routine 允许用户账号更改或删除存储过程，即允许使用alter function、alter procedure、drop function和drop procedure语句 create 允许使用create table 语句。如果想定义索引，还需要index权限 create routine 允许用户账号创建存储过程，即允许使用create function 和 create procedure 语句。并且，用户账号对自己创建的过程拥有alter routine权限 create temporary tables 允许使用create temporary tables 语句 create user 允许用户账号执行以下用户账号管理语句：create user、raname user、revoke all privileges和drop user create view 允许使用create view 语句 delete 允许使用delete语句 drop 允许使用drop table 和 truncate语句 event 允许用户账号为事件调度器创建事件，即允许使用create event、alter event 和 drop event 语句 execute 允许执行存储过程，即允许使用execute语句 file 允许使用select … into outfile 和 load data infile语句来导出数据到文件系统，或从文件系统导入数据。还有一个安全隐患。可通过secure_file_priv 变量来限制指定目录 index 允许使用create index 和 drop index 语句 insert 允许使用insert语句。这是执行analyze table、optimize table 和 repair table 语句的前提条件 lock tables 允许使用lock tables 语句，但用户必须先对表有select权限 process 允许使用show processlist和show endine语句 reload 允许使用flush 语句 replication client 允许用户查询主从服务器的状态信息，即允许使用show master status、show slave status 和 show binary logs语句 replication slave 进行从服务器复制时，需要此权限，它将允许读取主服务器的二进制日志事件 select 允许使用select 语句 show databases 允许使用show databases 语句来查看所有数据库，包括那些没有权限的数据库 show view 允许使用show create view 语句 shutdown 允许使用mysqladmin工具的shutdown选项 super 允许使用change master to、kill、purge binary logs、set global语句，以及mysqladmmin 工具的debug选项 trigger 允许用户账号创建或删除触发器，即允许使用create trigger 和 drop trigger 语句 update 允许使用update 语句 usage 可用于创建无权限的用户，或在不影响用户现有权限的情况下修改某某方面的属性 移除权限 revoke privileges on database.table from ‘username’@’..’; 获取会话标识 需process权限 show processlist; 结束会话 id为获取会话的id 需super权限 kill id; 强迫用户修改密码 alter user ‘username’@’localhost’ password expire; 修改密码123set password for &apos;username&apos;@&apos;localhost&apos; = &apos;encrpt_password&apos;;或者set password for &apos;username&apos;@&apos;localhost&apos; = password(&apos;password&apos;); 重置root密码123456新建文本文件，输入以下内容UPDATE mysql.user SET Password=PASSWORD(&apos;new_pwd&apos;) WHERE User=&apos;root&apos;;FLUSH PRIVILEGES;将该文件起名为rt-reset.sql，并放在受保护的目录，然后用 --init-file，启动mysql：mysqld_sefe --init-file=/root/rt-reset.sql &amp;改完之后，删除rt-reset.sql 用户改名 需create user和对mysql数据库update 权限 rename user ‘username’@’localhost’ to ‘newusername’@’localhost’; 创建角色 create role ‘role_name’; 授权给角色 grant privilege on databases.table to ‘rolename’@’localhost’; 给用户赋予角色 grant ‘role_name’ to ‘username’@’localhost’; 用户登陆后设定角色 set role ‘rolename’; 用户脱离角色 set role none;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.huizhe.xyz/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.huizhe.xyz/tags/MySQL/"}]},{"title":"python爬虫学习","slug":"python-crawler","date":"2017-10-16T06:23:40.000Z","updated":"2018-07-27T08:28:17.278Z","comments":true,"path":"python-crawler/","link":"","permalink":"https://www.huizhe.xyz/python-crawler/","excerpt":"python的爬虫相对来说，会比较容易上手一点，采用官方和第三方的类库实现 本篇文章采用requests，BeautifulSoup这两个第三方库来编写爬虫 并采用jieba分词，分析文本中的关键词及其权重","text":"python的爬虫相对来说，会比较容易上手一点，采用官方和第三方的类库实现 本篇文章采用requests，BeautifulSoup这两个第三方库来编写爬虫 并采用jieba分词，分析文本中的关键词及其权重 网页下载器1234import requestsresponse = requests.get(url)if response.status_code == 200 return response.content 在这里使用了http的get方式，传入要扒的网址，然后判断响应码 若返回200，则响应成功，返回html的内容 requests学习 网页分析器123import BeautifulSoupsoup = BeautifulSoup(html,'html.parser')print(soup.prettify()) 这里的html为上文中的response.content，并采用html_parser解析html 这里只是简单地打印了soup的内容而已 附上BeautifulSoup文档和一篇不错的博文 jieba分词地使用1234import jiebatags = jieba.analyse.extract_tags(sentence , topK=20, withWeight=True)for item in tags: print(item[0] + '\\t' + str(int(item[1] * 1000))) 此处使用jieba分词的基于TF-IDF关键词抽取 sentence 为待提取的文本 topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20 withWeight 为是否一并返回关键词权重值，默认值为 False 附上jieba分词github网址本文只是初步涉及python爬虫的学习，后续将继续学习，进阶python爬虫学习附上一篇实战的代码","categories":[{"name":"python","slug":"python","permalink":"https://www.huizhe.xyz/categories/python/"}],"tags":[{"name":"crawler","slug":"crawler","permalink":"https://www.huizhe.xyz/tags/crawler/"},{"name":"python","slug":"python","permalink":"https://www.huizhe.xyz/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-12T08:29:41.000Z","updated":"2018-07-27T08:20:09.452Z","comments":true,"path":"hello-world/","link":"","permalink":"https://www.huizhe.xyz/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"start","slug":"start","permalink":"https://www.huizhe.xyz/categories/start/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.huizhe.xyz/tags/hexo/"}]}]}